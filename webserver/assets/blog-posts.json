{
  "entities": {
    "first-games-of-40k": {
      "key": "first-games-of-40k",
      "permalink": "/blog/first-games-of-40k",
      "title": "My first games of Warhammer 40k",
      "date": "2023-12-20T20:40:00.000Z",
      "description": "I recently played my first two games of Warhammer 40k, and it was fun",
      "content": "Last year, I set myself the [goal](https://zoeaubert.me/blog/2022-a-year-in-review/) of playing at least one 1k-point game of 40k. This seemed like a reasonable goal at the time, but I didn't really start it till pretty late in the year.\n\nIt became a sprint towards the finish line, with me finishing the last of the painting the day before my first game. But the pressure was good, as it forced me to accept \"good enough,\" rather than spending hours chasing perfection. \n\n![12 Space Marines stood in two ranks. From left to right, there’s a Terminator Librarian in dark blue armour with gold trim. His right hand is behind him, holding an axe and his right hand is upheld and glowing blue. There’s then a squad of 5 Infernus Marines, who are all in purple and gold armour, with the Sergeant having a red helmet. They are all holding a flame thrower. The Sergeant has his strapped behind him and is throwing a grenade. Next is a Captain in Terminator armour. He is in purple and gold armour and is standing on the corpse of a Tyranid and some rocks. He has a gun in his left hand and a sword in his right. To the right of him is a squad of 5 Terminators in purple and gold armour. These have white helmets, except the sergeant, who has a red helmet with a white stripe. The non-Segargent models have guns and powerfits, while the Sergeant has a gun and a sword.](https://cdn.geekyaubergine.com/2023/12/07/026416d862a8eb46820f107c944a7ba7.jpeg)\n\nWhile I ultimately missed my goal of 1k points, with me painting only about 500 points. I did end up playing two games, so overall, that's 1k 🤣.\n\nApologies for the lack of proper photos and battle reports. As I'll cover, it was a little overwhelming, and I forgot to take photos most of the time. Also, I know I've made mistakes, so the battle reports wouldn't be particularly \"accurate\".\n\n## The Confessors\n\nI intend to cover this in more detail on a dedicated army page. Here's some lore/background on my army in the meantime.\n\nI like dudes in armour and big guns. When I was collecting [Age of Sigmar](https://en.wikipedia.org/wiki/Warhammer_Age_of_Sigmar), I collected [Slaves to Darkness](https://ageofsigmar.lexicanum.com/wiki/Slaves_to_Darkness). So, Space Marines were the obvious choice.\n\nI like purple and wanted to use it as a colour in one of my armies. But for a long time, I wrestled with the fact that the [Emperor's Children](https://warhammer40k.fandom.com/wiki/Emperor%27s_Children) pre-heresy wore purple and I didn't want to be caught up in that. So I dabbled with the [Imperial Fists](https://warhammer40k.fandom.com/wiki/Imperial_Fists) for a while before giving up because painting yellow is painful.\n\nAfter lamenting my choices with my friend, he convinced me to try doubling down on the \"totally not Emperor's Children\" angle. So I did. This then spawned \"The Confessors\". A [Chapter](https://warhammer40k.fandom.com/wiki/Chapter) who hunts the enemies of The Emperor and makes them \"confess\" their crimes and then pay for their sins. \n\nThe Confessors are led by Chapter Master Edward (another of my friend's brilliant suggestions), with each Captain taking a `Ed` name. For example, the name of my Terminator Captain featured here is `Edwin`. Their lore is still mostly under construction, but it's filled with many tongue-in-cheek references, such as they practice excellent (not perfect) warfare and focus on looking their best (again, not perfect). \n\n## Game 1\n\n![A battlefield with various bits of terrain. In the bottom right corner is six purple Space Marines in Terminator Armour hiding behind a ruin. At the bottom left are five purple Infernus Marines hiding behind a ruin. In the centre are ten Necron Warriors and a Necron Overlord.](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5365.JPG)\n\nMy first game was an \"introduction to 40k\" session at my local Warhammer shop. This wasn't a real battle in any real sense of the word. This was more of a \"check I know the basic mechanics\" sort of session. I was playing against a similarly sized force of [Nerons](https://warhammer40k.fandom.com/wiki/Necrons).\n\nAs this was my first game and I knew Necron weapons could be pretty scary, I didn't want to get wiped, so I played it pretty cagey. This was my first mistake of many.\n\nThe Necron player got the first turn, but all they could really do was move up towards me (to the positions in the photo above). If I had asked more about their units before deploying, I would've found out that they had shorter-range weapon options and couldn't do much to me anyway. \n\nIt was then my turn. This revealed my second and third blunders. My [Infernus Marines](https://warhammer40k.fandom.com/wiki/Infernus_Squad) (left) did 0 damage to the [Skorpekh Destroyers](https://warhammer40k.fandom.com/wiki/Skorpekh_Destroyer) (left) as I grossly misunderstood how tough they were. Then my [Terminators](https://warhammer40k.fandom.com/wiki/Terminators) (right) did some damage to the [Necron Warriors](https://warhammer40k.fandom.com/wiki/Necron_Warrior) (upper middle), but due to hiding in a building, I prevented some of my models having a line of sight and being able to shoot.\n\nI knew at this point I'd made some serious errors. I assumed my Infernus Marines would do more damage and that the Necrons would've been scarier. What I should've done is move both my units towards the centre of the board and lay down some heavy fire on the Necron Warriors while I had the chance. What was going to happen next was obvious.\n\n![Five purple Infernus Marines facing three Necron Skorpekh Destroyers wielding light green blades. They are stood next to a bit of scenery and some tinsel from a Christmas tree](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5375.JPG)\n\nThe Necron player advanced their Warriors to the centre and then charged the Skorpekhs into my Infernus Marines. To say the Skorpekhs wiped my Marines would be an understatement. They were overkilled by a hilarious margin. After that, I was ready for my Terminators to also take a beating, but it turns out their armour is _much_ better than I thought, and they just shrugged off the 20-odd shots, taking only a single wound.\n\nIt was then my turn to exact my revenge. On the advice of my opponent to trust in my Terminator's melee strength, I shot at the Warriors, taking a few out and then charged the Skorpekhs. To say I was impressed would be an understatement. The high strength and armour penetration of the [Power Fists](https://warhammer40k.fandom.com/wiki/Power_Fist) is awesome. They took out 2 of the Skorpekh and left another low for my Captain to finish off with his sword. \n\n![Six purple Space Marines in Terminator Armour facing three Necron Skorpekh Destroyers wielding light green blades](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5379.JPG)\n\nThis very quickly turned from what I thought was an easy loss into a clear win. The Necrons continued to fail to shoot me off the table while I simply shot and then followed up with melee attacks that saw them die. The [Necron Overlord](https://warhammer40k.fandom.com/wiki/Necron_Overlord) (robot with the tall spear) did manage to kill off one of my Terminators with his [Tachyon Arrow](https://warhammer40k.fandom.com/wiki/Tachyon_Arrow), which, while very deadly, only has one attack so could only kill one model.\n\n![Five purple Space Marines in Terminator armour fighting a Necron Overlord with four Necron Warriors in the background](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5381.JPG)\n\nWhile I know the opponent made some intentional \"blunders\" to ensure I didn't automatically lose the game, I was thoroughly impressed by how powerful my Terminators were and had a great time. \n\nIt was overwhelming though. While I thought I knew the game well enough to play, actually doing it and being required to remember everything the instant I needed it proved much more difficult than I expected. However, some of it was already becoming easier by the end of this first game.\n\n## Game 2\n\nMy next game was against my friend who got me into 40k and made many of the lore suggestions for the Confessors. He was playing his [Genestealer Cult](https://warhammer40k.fandom.com/wiki/Genestealer_Cult). \n\nI thought I knew this army and how it operated from our numerous hours discussing our units and all the cool things they can do. As we both only really have the [Combat Patrol](https://warhammer40000.com/combat-patrol/)'s to play with, so we did that. \n\nYou'll also see that we each have our [Red Gobbo](https://www.warhammer-community.com/2023/11/03/get-ready-to-spread-festive-cheer-with-da-red-gobbos-surprise/)'s in our armies. They don't belong in our armies, but there's an option to play a game with them to get some free festive dice, and as we both had one, there were no real advantages to either player.\n\nThis was both my and my friend's first non-store-led games, so it was very slow and full of mistakes and uncertainties about the rules. These games are supposed to last about an hour. This turned into a three-hour slogfest.\n\nWe both seemed rather afraid of what could happen, so we both decided to make use of our deep-strike rules (start with some models off the board and have them appear later) and have some of the models start in reserve. I then got the first turn and teleported my Terminators on top of the centre objective. (Hidden behind my Captain). The sellotape was acting as my marker, but I forgot to remove it before I took the picture.\n\n![A battlefield split in the middle by a boxy bit of terrain that splits the area. On the lower area behind the terrain is a Genestealer truck and 5 Acolytes. On the terrain is six purple Space Marines in Terminator Armour. At the front on the lower level are 5 Infernus Marines in purple armour and a Librarian in dark blue armour. The battle field has several other terrain features, including some boxes, creates and a circular power generator](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5387.JPG)\n\nI knew that with most of the [Neophyte Hybrids](https://warhammer40k.fandom.com/wiki/Neophyte_Hybrid) being in reserve, I needed to protect my home objectives, so I chose not to move the Infernus Marines or the Gobbo (he's off to the right corner of the board). This left me only shooting at the [Goliath Rockgrinder](https://www.warhammer.com/en-WW/shop/goliath-rockgrinder-2016) with my Terminators. I vastly underestimated the Rockgrinder's toughness, and all of my shots did a single wound.\n\nThings only got worse from here. My opponent moved his Rockgrinder up to near Terminators and disembarked his [Aberrants](https://warhammer40k.fandom.com/wiki/Aberrant) (or as he affectionally calls them, \"muscle beach\") right in my face.\n\n![5 purple Space Marines in Terminator Armour facing left with 5 Aberrants approaching them holding various improvised weapons including a road sign](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5390.JPG)\n\nThe Rockgrinder then shot, and it slapped hard. Thankfully, my Terminators have a 4+ (on a D6 roll equal or better than a 4) invulnerable save, or they've been toast. I rolled pretty well and only lost a single Terminator, but damn. Muscle Beach then charged, laid down the pain and took out another Terminator.\n\nThanks to being able to respond in my opponent's fight phase and then again in my turn, I managed to take out a few of the beachgoers before taking any more losses. Unfortunately, I made another mistake when removing my dead models, leaving the sergeant with a sword rather than keeping another power fist. I should've kept the power fist instead, as it has much higher strength, and it would've been much more effective against these enemies. Though, as I didn't kill the unit, it meant that the Rockgrinder could not shoot at my Terminators, which probably saved their lives (this is how we interpreted the rules; I think we're wrong, but oh well).\n\n![Four purple Space Marines stood on a boxy bit of terrain facing a single Aberrant. Off to the side of the terrain is an unpainted truck. In the background is a large group of Neophyte Hybrids](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5392.JPG)\n\nI did move my Infernus Marines around the corner to the left, trying to keep away from the Rockgrinder as it was obviously going to make the charge against them, but it didn't work.\n\nAs predicted, he moved his Rockgrinder up to my Infernus Marines on my opponent's turn. He also deployed his Neophytes on his home objective and dropped his [Acolyte Hybrids](https://warhammer40k.fandom.com/wiki/Acolyte_Hybrid) as close as possible to my Terminators. \n\nThe Acolytes and Rockgrinder then charged respectively. The Acolytes did nothing to my Terminators, but the Rockgrinder decimated my Infernus Marines.\n\n![A battle scene split into two levels by a boxy bit of terrain. On the top level are four purple Space Marines in Terminator Armour fighting a single Aberrant and 5 Acolyte Hybrids. On the lower level is an unpainted truck fighting two purple Infernus Marines and a dark blue Librarian. The the background is a large group of Neophyte Hybrids](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5400.JPG)\n\nEnter the Red Gobbo. \n\nOn my next turn, as a somewhat last-ditch effort, I got my Gobbo involved and tagged him into combat with the Rock grinder. Astonishingly, he managed to do a wound to it. However, his primary goal was to pin the Rockgrinder down.\n\n![A battle scene split into two levels by a boxy bit of terrain. On top of the terrain are three purple Space Marines in Terminator Armour fighting a Genestealer Aberrant with a red dice next to it showing one. On the lower level is a unpainted truck with a purple Infernus Marine, a dark blue Librarian in Terminator Amour and a Ork in a Santa costume on a snowy base ](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5405.JPG)\n\nI then finished off the final Aberrant and moved my Terminators towards his home objectives. From here, it was a bit of a grind with us each taking out models, though he has the annoying ability to bring back a fair few models from the dead. This led to my Terminators being surrounded again. He also tagged his Gobbo into the fray.\n\n![Two purple Space Marines in Terminator Armour surrounded by numerous unpainted Genestealer models and an Ork in a Santa costume on a snowy base](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5416.JPG)\n\nEventually, the Rockgrinder got through the Infernus Marines, Librarian and Gobbo and caught up with my Terminators.\n\nMy opponent then played a genius move of retreating his Neophytes so that the Rockgrinder could fire on my Terminators. This then left Captain Edwin all by himself to face the enemy.\n\n![Purple Captain in Terminator Armour facing a Genestealer truck with red dice on it reading 7. Stood near the Captain are numerous unpainted Genestealer models](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5419.JPG)\n\nI'm sure you can imagine what happened next. Despite his heroic last stand, he eventually was overwhelmed. \n\n![A purple Captain in Terminator Armour is surrounded by numerous unpainted Genestealer Cult models, including a truck. The truck as red dice on it reading 7](https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5425.JPG)\n\n## Thoughts\n\nThis was great. I had a feeling I'd enjoy this, and I did. I made a lot of mistakes that I hope I've learned from and won't make again. None of the mistakes feel bad, which is good, I feel I can correct them with more experience rather than it being insurmountable.\n\nThere's a lot of information to process, and reading/flipping through the books is far too clunky. I/we used a fair bit of time just finding useful information. So I need to make myself some cheat/crib sheets to take along, which should help with that too.",
      "tags": [
        "Warhammer",
        "Warhammer40k",
        "SpaceMarines",
        "Confessors",
        "BattleReport",
        "Necrons",
        "Genestealers"
      ],
      "hero": {
        "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5365-min.JPG",
        "alt": "A battlefield with various bits of terrain. In the bottom right corner is six purple Space Marines in Terminator Armour hiding behind a ruin. At the bottom left are five purple Infernus Marines hiding behind a ruin. In the centre are ten Necron Warriors and a Necron Overlord",
        "date": "2023-12-20T20:40:00.000Z",
        "parentPermalink": "/blog/first-games-of-40k",
        "width": 1024,
        "height": 768,
        "orientation": "landscape",
        "title": null
      },
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/07/026416d862a8eb46820f107c944a7ba7.jpeg",
          "alt": "12 Space Marines stood in two ranks. From left to right, there’s a Terminator Librarian in dark blue armour with gold trim. His right hand is behind him, holding an axe and his right hand is upheld and glowing blue. There’s then a squad of 5 Infernus Marines, who are all in purple and gold armour, with the Sergeant having a red helmet. They are all holding a flame thrower. The Sergeant has his strapped behind him and is throwing a grenade. Next is a Captain in Terminator armour. He is in purple and gold armour and is standing on the corpse of a Tyranid and some rocks. He has a gun in his left hand and a sword in his right. To the right of him is a squad of 5 Terminators in purple and gold armour. These have white helmets, except the sergeant, who has a red helmet with a white stripe. The non-Segargent models have guns and powerfits, while the Sergeant has a gun and a sword.",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 3527,
          "height": 2351,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5365.JPG",
          "alt": "A battlefield with various bits of terrain. In the bottom right corner is six purple Space Marines in Terminator Armour hiding behind a ruin. At the bottom left are five purple Infernus Marines hiding behind a ruin. In the centre are ten Necron Warriors and a Necron Overlord.",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5375.JPG",
          "alt": "Five purple Infernus Marines facing three Necron Skorpekh Destroyers wielding light green blades. They are stood next to a bit of scenery and some tinsel from a Christmas tree",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5379.JPG",
          "alt": "Six purple Space Marines in Terminator Armour facing three Necron Skorpekh Destroyers wielding light green blades",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5381.JPG",
          "alt": "Five purple Space Marines in Terminator armour fighting a Necron Overlord with four Necron Warriors in the background",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5387.JPG",
          "alt": "A battlefield split in the middle by a boxy bit of terrain that splits the area. On the lower area behind the terrain is a Genestealer truck and 5 Acolytes. On the terrain is six purple Space Marines in Terminator Armour. At the front on the lower level are 5 Infernus Marines in purple armour and a Librarian in dark blue armour. The battle field has several other terrain features, including some boxes, creates and a circular power generator",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5390.JPG",
          "alt": "5 purple Space Marines in Terminator Armour facing left with 5 Aberrants approaching them holding various improvised weapons including a road sign",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5392.JPG",
          "alt": "Four purple Space Marines stood on a boxy bit of terrain facing a single Aberrant. Off to the side of the terrain is an unpainted truck. In the background is a large group of Neophyte Hybrids",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5400.JPG",
          "alt": "A battle scene split into two levels by a boxy bit of terrain. On the top level are four purple Space Marines in Terminator Armour fighting a single Aberrant and 5 Acolyte Hybrids. On the lower level is an unpainted truck fighting two purple Infernus Marines and a dark blue Librarian. The the background is a large group of Neophyte Hybrids",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5405.JPG",
          "alt": "A battle scene split into two levels by a boxy bit of terrain. On top of the terrain are three purple Space Marines in Terminator Armour fighting a Genestealer Aberrant with a red dice next to it showing one. On the lower level is a unpainted truck with a purple Infernus Marine, a dark blue Librarian in Terminator Amour and a Ork in a Santa costume on a snowy base ",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5416.JPG",
          "alt": "Two purple Space Marines in Terminator Armour surrounded by numerous unpainted Genestealer models and an Ork in a Santa costume on a snowy base",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5419.JPG",
          "alt": "Purple Captain in Terminator Armour facing a Genestealer truck with red dice on it reading 7. Stood near the Captain are numerous unpainted Genestealer models",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/12/first-game-of-40k/IMG_5425.JPG",
          "alt": "A purple Captain in Terminator Armour is surrounded by numerous unpainted Genestealer Cult models, including a truck. The truck as red dice on it reading 7",
          "date": "2023-12-20T20:40:00.000Z",
          "parentPermalink": "/blog/first-games-of-40k",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "advent-of-code-is-not-healthy-for-me": {
      "key": "advent-of-code-is-not-healthy-for-me",
      "permalink": "/blog/advent-of-code-is-not-healthy-for-me",
      "title": "Advent of Code is not healthy for me",
      "date": "2023-12-13T19:30:00.000Z",
      "description": "Advent of Code is not healthy for me. A look at how it taps into my negative traits and why I must stop participating. CW; Mental health.",
      "content": "This year is the first time I've participated in [Advent of Code](https://adventofcode.com/), and it's caused me some problems and highlighted some issues I need to address.\n\nContent warning for discussions of my mental health.\n\n## My Problem\n\nI was planning to explore some of this in my EndOfYearPost™️, but now's as good a time as any. \n\nThis year has been a fun delve into my mental health. Not with a professional, but with myself, so take everything with a handful of salt.\n\nA core part of my mentality is based on my performance. I must at all times be performing my best while performing increasingly impressive \"feats\" (take that to mean what you will). While this problem isn't isolated to just programming, that's part of a wider discussion.\n\nIf I'm not performing my best, then I feel terrible. That can mean many things. Maybe I'm stuck on a problem that \"should\" be solvable. Maybe I can't do the \"right\" thing because of time constraints. Sometimes, it's not even my \"fault\". The library I'm trying to use doesn't work as well as expected or similar, and it leads to endless unsolvable problems, (this has been particularly relevant to me professionally in recent times as I've been working with mobile device cameras). Any one of these things can ruin an otherwise great day/week.\n\nTo satisfy this need to perform at the highest levels, I keep starting more and more complex projects. Aiming higher and higher. I've tried many things, from building a stock-trading bot to making a search engine and an MMO. Only for every one of the projects to be abandoned. And with each abandonment comes failure, with each being more painful than the last. Ask my friends; we did a tally a while back and came to something like 80 unfinished/abandoned projects 🫠. And, of course, the only logical way to redeem myself for a failed project is to start and complete an even more complex one.\n\nAfter the discussion where my friends and I tallied up my unfinished projects, I swore a vow not to start a new project until I completed one. I did not want the number of projects to increase any further and add to my perceived failures. I was doing well, even completing some of them, including shipping my [hackathon project](https://zoeaubert.me/blog/hackathon-accelos/), finishing the redesign of this website, and [painting some Warhammer models](https://zoeaubert.me/micros/2023/12/111539387340900611/).\n\n## Programming Challenges\n\nFor many years, I have found a great source of pride (and big-headedness) in being able to solve \"hard\" programming challenges. Initially, many of these came from the projects I was working on, such as various graphics-related problems from making games or inverse kinematics from my foray into building a robotics simulator.\n\nAs the years went on, I ran out of fun project ideas and turned to other programming challenges such as [LeetCode](https://leetcode.com/), [CodeCademy](https://www.codecademy.com/) and [Project Euler](https://projecteuler.net/).\n\nI never found the first two particularly inspiring, mostly just things I'd had to solve myself previously, and if it's not new, I'm not interested. Project Euler, though, captured me.\n\nWhile I'm not good enough at maths to understand some of the problems, it didn't stop me from trying. I've spent what I can only refer to as a silly number of hours trying some of these. Thankfully, because these are \"maths hard\" rather than \"computer science\" hard, I didn't take my inability to solve some of them too much to heart.\n\nAs another by-product of them being mostly \"maths based\", I wasn't able to get many of my friends to participate, so there was no-one I could really compete with.\n\nThis should have been a warning of what would come if I tried Advent of Code.\n\n## Advent of Code\n\n### The competitiveness \n\nOn rolls the first of December, and I'm feeling good. After having a go at it, I mentioned it to some of my friends, who also decided to give it a go. Great, now I am not only competing against the internet, I'm competing against people I know, and I have to prove that I'm better than them.\n\nHere in lies the first problem. My primary motivation for Advent of Code was not \"Can I complete these?\", but \"Can I complete them faster and better?\" than others. Maybe I knew this from the start, but I might've (and likely did) repress that as I knew it was bad. \n\nThis got out of hand. Not only was I waking up early to be first, but I was spending every break I got working on the problems. Getting the answer was no longer enough. With other people posting their code and benchmarks, I had something even better to strive for. Solving it was no longer enough. I had to have the most optimal solution. My code had to be faster and better written.\n\nOftentimes, these optimisations took much longer than just solving the problem. Those are hours I'll never get back, chasing performance metrics that ultimately don't matter and no one was actually competing with.\n\n### The Blogging\n\nAt the start of the first day, I hadn't even thought about posting anything to do with Advent of Code, but then, [Robb](https://rknight.me/) showed me [Lewis'](https://lewisdale.dev/post/advent-of-code-2023-day-one/) post, and it got me considering it.\n\nI love talking about and teaching programming, so this seemed an obvious choice. So, after some faffing with getting the style right, I posted my [first post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/).\n\nWith that simple post, I signed myself into an unwritten contract that would not only solve all the problems but also write about them. So when day 10 came, and I didn't finish the problems, it was not only a personal failure, but it also felt like a very public failure. I know it's not, and I wasn't the only person who didn't finish that day, but because I'd made an effort to write about all the other days, it felt worse than if I hadn't.\n\nAnother unfavourable aspect of blogging was it was a very public statement of \"here's what I can do, beat it if you dare\", which is less than healthy.\n\n### The Camels Back\n\nI'm not exactly sure where it fell apart and became an obvious problem. Day ten was an obvious marker, and missing day 12 was probably the final straw, but I think the problem appeared earlier when I almost made myself late for things because I was busy either solving the problem or writing about my solution.\n\nThe first few days were great, but as time went on, the problems required more and more time, which I ultimately didn't have, and I was starting to sacrifice important things. Also, the pace required to keep up is relentless.\n\nAs the days progressed, fewer people were posting, and my friends' enthusiasm also seemed to die. And I sadly think that's what ultimately did it. I'd already \"lost\" to the internet as there we still lots of people completing the challenges I could not. And I'd already \"won\" within the circle of people I know.\n\n## What Now?\n\nToday was the day of reckoning. I don't know if it's because I got an unusually good night's sleep, or what, but I saw clearly what was happening. Advent of Code, and the self-imposed competitiveness around it, was fuelling one of my toxic traits and causing me problems, and it had to stop.\n\nI'm pleased I've got this far, I didn't know how far I'd get, and I didn't reasonably expect to be able to do all of the challenges. But I've survived the first few big challenges that saw lots of people leaving and I should be proud of that.\n\nI might revisit these in the future. If I do, I think I'll do so privately without posting about it. But for now, I'm done. I should spend my time on less toxic things and enjoy the holidays.\n\n### PS\n\nThis is not a reflection of Advent of Code or anyone else who enjoys it. If you can enjoy it in a healthy way, then you should continue too 🙂.\n",
      "tags": [
        "Health",
        "AdventOfCode"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-11": {
      "key": "advent-of-code-2023-day-11",
      "permalink": "/blog/advent-of-code-2023-day-11",
      "title": "Advent of Code 2023 - Day 11",
      "date": "2023-12-11T23:00:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 11. Today was a day of mistakes. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-11) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Part 1\n\nToday saw us finding the distances between galaxies with some interesting twists. Read the [problem statement](https://adventofcode.com/2023/day/11), as it explains it pretty well. I went down many mistaken paths today trying to predict what would come, and it didn't work out 🤣.\n\n### Mistake 1\n\nI started with a recurring feature of these challenges, and created a`Input` struct.\n\n```rust\nstruct Input {\n    chars: Vec<char>,\n    width: usize,\n    height: usize,\n}\n\nimpl Input {\n    fn new(input: &str) -> Self {\n        let lines = input.lines().map(|l| l.trim()).collect::<Vec<_>>();\n        let width = lines[0].len();\n\n        // Expand \"empty\" rows to two \"empty\" rows\n        let rows = lines\n            .iter()\n            .flat_map(|row| {\n                if row.chars().all(|c| c == '.') {\n                    vec![row, row]\n                } else {\n                    vec![row]\n                }\n            })\n            .collect::<Vec<_>>();\n\n        let height = rows.len();\n\n        let mut cols = vec![];\n\n        for x in 0..width {\n            let mut col = vec![];\n            for y in 0..height {\n                col.push(rows[y].chars().nth(x).unwrap());\n            }\n            cols.push(col);\n        }\n\n        let cols = cols\n            .iter()\n            .flat_map(|col| {\n                if col.iter().all(|&c| c == '.') {\n                    vec![col.clone(), col.clone()]\n                } else {\n                    vec![col.clone()]\n                }\n            })\n            .collect::<Vec<_>>();\n\n        let width = cols.len();\n\n        let mut chars = vec![];\n\n        for y in 0..height {\n            for x in 0..width {\n                chars.push(cols[x][y]);\n            }\n        }\n\n        Self {\n            chars,\n            width,\n            height,\n        }\n    }\n\n    fn to_string(&self) -> String {\n        let mut s = String::new();\n        for y in 0..self.height {\n            for x in 0..self.width {\n                s.push(self.chars[y * self.width + x]);\n            }\n            s.push('\\n');\n        }\n        s\n    }\n\n    fn get(&self, x: usize, y: usize) -> Option<char> {\n        if x >= self.width || y >= self.height {\n            None\n        } else {\n            Some(self.chars[y * self.width + x])\n        }\n    }\n}\n```\n\nIn my infinite wisdom, I chose to deal with the \"empty row/column counting as two rows/columns\" by actually expanding the input and adding additional characters to it. In hindsight, it was absolute madness, but in my barely awake state this morning, seemed like a genius move. Everything else in it is pretty normal.\n\n### Mistake 2\n\n```rust\nstruct Galaxy {\n    id: u16,\n    x: f32,\n    y: f32,\n}\n\nimpl Galaxy {\n    fn new(id: u16, x: f32, y: f32) -> Self {\n        Self { id, x, y }\n    }\n\n    fn distance(&self, other: &Self) -> f32 {\n        let mut distance = 0.0;\n\n        let mut x = self.x;\n        let mut y = self.y;\n\n        while x != other.x || y != other.y {\n            let dx = other.x - x;\n            let dy = other.y - y;\n\n            if dx.abs() >= dy.abs() {\n                x += dx.signum();\n            } else {\n                y += dy.signum();\n            }\n\n            distance += 1.0;\n        }\n\n        distance\n    }\n}\n```\n\nNext, I built myself a `Galaxy` struct. Here lies my second of many follies. When working out the distance between two galaxies, I first turned to what I thought was the genius move of using a [rasterisation](https://en.wikipedia.org/wiki/Rasterisation) style approach to working out what \"grid\" slots the shortest distance span across, and using that to work out the \"grid distance\". \n\nThis initially worked for the first few tests, giving me a false sense of hope. But, later on (after building the rest of the program), I would discover it was wrong for more test cases. After abandoning that approach, I turned to what seemed like a safer bet. Work out the delta between the two points, and then walk in that direction one cell at a time in the direction of the greatest delta. And sure enough, it worked, but boi, was it slow. I couldn't see any optimisation for it, so I gave it no more thought at this point.\n\n### Mistake 3\n\nI chanced a glance into the future as to what part 2 might contain, and suspected some more difficult pathfinding would come, something like \"shortest path between all points\", or \"shortest spanning tree between all points\". With that in mind, I decided it would probably be useful to cache the distance between any two given galaxies.\n\n```rust\nfn galaxy_distance_hash_id(galaxy_a: u16, galaxy_b: u16) -> u32 {\n    let min = galaxy_a.min(galaxy_b);\n    let max = galaxy_a.max(galaxy_b);\n\n    (min as u32) << 16 | (max as u32)\n}\n\nstruct GalaxyMap {\n    galaxies: HashMap<u16, Galaxy>,\n    galaxy_distances: HashMap<u32, u32>,\n}\n\nimpl GalaxyMap {\n    fn new() -> Self {\n        Self {\n            galaxies: HashMap::new(),\n            galaxy_distances: HashMap::new(),\n        }\n    }\n\n    fn from_input(input: &Input) -> Self {\n        let mut map = Self::new();\n\n        let mut id = 1;\n\n        for y in 0..input.height {\n            for x in 0..input.width {\n                if input.get(x, y) == Some('#') {\n                    map.add(Galaxy::new(id, x as f32, y as f32));\n                    id += 1;\n                }\n            }\n        }\n\n        map\n    }\n\n    fn add(&mut self, galaxy: Galaxy) {\n        self.galaxies.insert(galaxy.id, galaxy);\n    }\n\n    fn distance(&mut self, a: u16, b: u16) -> u32 {\n        let key = galaxy_distance_hash_id(a, b);\n        if let Some(distance) = self.galaxy_distances.get(&key) {\n            *distance\n        } else {\n            let distance = self.galaxies[&a].distance(&self.galaxies[&b]) as u32;\n            self.galaxy_distances.insert(key, distance);\n            distance\n        }\n    }\n\n    fn galaxy_ids(&self) -> Vec<u16> {\n        self.galaxies.keys().copied().collect::<Vec<_>>()\n    }\n}\n```\n\nFrom there, it was easy to process the necessary data.\n\n```rust\npub fn process(input: &str) -> Result<u32> {\n    let input = Input::new(input);\n\n    let mut map = GalaxyMap::from_input(&input);\n\n    let galaxy_ids = map.galaxy_ids();\n\n    let mut total_distance = 0;\n\n    for a in 0..galaxy_ids.len() {\n        for b in a + 1..galaxy_ids.len() {\n            let distance = map.distance(galaxy_ids[a], galaxy_ids[b]);\n            total_distance += distance;\n        }\n    }\n\n    Ok(total_distance)\n}\n```\n\nCool. I was feeling good, I felt like I knew what twist was coming and was ready for it.\n\nI then saw part 2. Each empty row/column isn't one additional empty row/column but is actually 1 million more rows/columns. This was not a twist I foresaw, and I knew immediately that my code would not support it.\n\n## Optimisation (aka fixing past mistakes)\n\nI decided part 2 was impossible without fixing my previous mistakes, so I did this first, which is different to my usual approach.\n\n### Fix 1\n\nGrowing the input to be several million rows and columns is not feasible. So that had to change.\n\n```rust\nstruct Input {\n    chars: Vec<char>,\n    width: usize,\n    height: usize,\n    empty_rows: Vec<usize>,\n    empty_cols: Vec<usize>,\n}\n\nimpl Input {\n    fn new(input: &str) -> Self {\n        let lines = input.lines().map(|l| l.trim()).collect::<Vec<_>>();\n\n        let width = lines[0].len();\n        let height = lines.len();\n\n        let chars = lines.iter().flat_map(|l| l.chars()).collect::<Vec<_>>();\n\n        let empty_rows = (0..height)\n            .filter(|y| {\n                for x in 0..width {\n                    if chars[*y * width + x] == '#' {\n                        return false;\n                    }\n                }\n                true\n            })\n            .collect::<Vec<_>>();\n\n        let empty_cols = (0..width)\n            .filter(|x| {\n                for y in 0..height {\n                    if chars[y * width + *x] == '#' {\n                        return false;\n                    }\n                }\n                true\n            })\n            .collect::<Vec<_>>();\n\n        Self {\n            chars,\n            width,\n            height,\n            empty_rows,\n            empty_cols,\n        }\n    }\n\n    fn to_string(&self) -> String {\n        let mut s = String::new();\n        for y in 0..self.height {\n            for x in 0..self.width {\n                s.push(self.chars[y * self.width + x]);\n            }\n            s.push('\\n');\n        }\n        s\n    }\n\n    fn get(&self, x: usize, y: usize) -> Option<char> {\n        if x >= self.width || y >= self.height {\n            None\n        } else {\n            Some(self.chars[y * self.width + x])\n        }\n    }\n\n    fn is_row_empty(&self, y: usize) -> bool {\n        self.empty_rows.contains(&y)\n    }\n\n    fn is_col_empty(&self, x: usize) -> bool {\n        self.empty_cols.contains(&x)\n    }\n}\n```\n\nLong gone is transforming the input. The only semi-clever thing going on here is pre-computing all the empty rows/columns before I need them. This is still quite messy, or at least I think it is. There are probably a few things you could do to fix it. The empty checks feel particularly scuffed.\n\n### Fix 2\n\nThis was more a stroke of luck than a stroke of genius. In trying to optimise the distance calculation I tried a great many things, including the Pythagorean theorem. While this turned out to be useless, I did notice that the x and y delta just happened to be the same as the distance. This greatly simplifies the calculation.\n\n```rust\nimpl Galaxy {\n    #[tracing::instrument]\n    fn new(id: u16, x: f32, y: f32) -> Self {\n        Self { id, x, y }\n    }\n\n    #[tracing::instrument]\n    fn distance(&self, other: &Self) -> f32 {\n        let dx = other.x - self.x;\n        let dy = other.y - self.y;\n\n        dx.abs() + dy.abs()\n    }\n}\n```\n\nI feel like with the number of grid-based games I've created over the years I'd have known this. Useful to know now though.\n\n### Fix 3\n\nThe `GalaxyMap` was the next thing on the chopping block. As we're not doing anything clever with the input to create the additional empty rows/columns, we need to do it here. Rather than just looking at galaxies, we need to go row by row and add a running offset for each empty row. Similar for columns.\n\nThe second thing is removing the cache. We're only checking each pairing once, so we're never going to look it up.\n\n```rust\nstruct GalaxyMap {\n    galaxies: HashMap<u16, Galaxy>,\n}\n\nimpl GalaxyMap {\n    fn new() -> Self {\n        Self {\n            galaxies: HashMap::new(),\n        }\n    }\n\n    fn from_input(input: &Input) -> Self {\n        let mut map = Self::new();\n\n        let mut id = 1;\n\n        let mut y_offset = 0;\n\n        for y in 0..input.height {\n            if input.is_row_empty(y) {\n                y_offset += 1;\n            }\n            let mut x_offset = 0;\n            for x in 0..input.width {\n                if input.is_col_empty(x) {\n                    x_offset += 1;\n                }\n                if input.get(x, y) == Some('#') {\n                    map.add(Galaxy::new(\n                        id,\n                        (x + x_offset) as f32,\n                        (y + y_offset) as f32,\n                    ));\n                    id += 1;\n                }\n            }\n        }\n\n        map\n    }\n\n    fn add(&mut self, galaxy: Galaxy) {\n        self.galaxies.insert(galaxy.id, galaxy);\n    }\n\n    fn distance(&self, a: u16, b: u16) -> u32 {\n        self.galaxies[&a].distance(&self.galaxies[&b]) as u32\n    }\n\n    fn galaxy_ids(&self) -> Vec<u16> {\n        self.galaxies.keys().copied().collect::<Vec<_>>()\n    }\n}\n```\n\nWith those optimisations, I got the speed boost I needed. It went from 44ms to 730µs. I'd usually chalk that up to a genius performance increase, but I think it just highlights how bad my first attempt was 🤣.\n\n## Part 2\n\nAfter the optimisation, part 2 was easy and only required 2 changes. Changing all the values from `u32` -> `u64` and `f32` -> `f64` (possibly not needed), and changing the offsets to `999,999`.\n\n```rust\nimpl GalaxyMap {\n    fn from_input(input: &Input) -> Self {\n        let mut map = Self::new();\n\n        let mut id = 1;\n\n        let mut y_offset = 0;\n\n        for y in 0..input.height {\n            if input.is_row_empty(y) {\n                y_offset += 999_999;\n            }\n            let mut x_offset = 0;\n            for x in 0..input.width {\n                if input.is_col_empty(x) {\n                    x_offset += 999_999;\n                }\n                if input.get(x, y) == Some('#') {\n                    map.add(Galaxy::new(\n                        id,\n                        (x + x_offset) as f64,\n                        (y + y_offset) as f64,\n                    ));\n                    id += 1;\n                }\n            }\n        }\n\n        map\n    }\n    }\n```\n\n## Thoughts\n\nToday wasn't actually _that_ difficult, I just made it harder than it needed to be by making a litany of errors.\n\nI've also written this in a different style than usual. Rather than presenting the correct solution and why it worked, I thought it would be more entertaining to explore the issues of my own creation and how I fixed them. Hopefully, you enjoyed it.\n\n## Results\n\n```\nday_11        fastest       │ slowest       │ median        │ mean\n├─ part1      43 ms         │ 49.85 ms      │ 44.31 ms      │ 44.43 ms\n├─ part1_opt  621.2 µs      │ 1.266 ms      │ 721 µs        │ 731.8 µs\n╰─ part2      612.7 µs      │ 1.052 ms      │ 718.6 µs      │ 733.2 µs\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-09": {
      "key": "advent-of-code-2023-day-09",
      "permalink": "/blog/advent-of-code-2023-day-09",
      "title": "Advent of Code 2023 - Day 09",
      "date": "2023-12-09T11:00:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 09. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-09) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday saw us extrapolating numbers using a specific technique. I don't think I can explain the [problem](https://adventofcode.com/2023/day/9) any better than it already is.\n\nThe first step was taking a first series of numbers `0 3 6 9 12 15` and producing the differences between each of them so that you get a result like this:\n\n```\n0   3   6   9  12  15\n  3   3   3   3   3\n```\n\n```rust\nfn calculate_differences(values: &[i32]) -> Vec<i32> {\n    let mut differences = Vec::new();\n    for i in 0..values.len() - 1 {\n        differences.push(values[i + 1] - values[i]);\n    }\n    differences\n}\n```\n\nThe only slightly complex part was repeating this step until you reached a row of all `0` and then working up the right edge to get the extrapolations.\n\n```rust\nfn extrapolate_value(input: &[i32]) -> Result<i32> {\n    let mut values = vec![input.to_vec()];\n\n    loop {\n        let bottom = values\n            .last()\n            .ok_or_else(|| Error::CouldNotGetBottomRowOfValues)?;\n\n        if bottom.iter().all(|n| *n == 0) {\n            break;\n        }\n\n        values.push(calculate_differences(bottom));\n    }\n\n    for row_index in (0..values.len() - 1).rev() {\n        let row_last_value = values[row_index]\n            .last()\n            .ok_or_else(|| Error::CouldNotGetLastValueOfRow(row_index))?;\n\n        let row_below_last_value = values[row_index + 1]\n            .last()\n            .ok_or_else(|| Error::CouldNotGetLastValueOfRow(row_index + 1))?;\n\n        let next_value = row_last_value + row_below_last_value;\n\n        values[row_index].push(next_value);\n    }\n\n    Ok(values[0][values[0].len() - 1])\n}\n\npub fn process(input: &str) -> Result<i32> {\n    let input = input\n        .lines()\n        .map(|line| {\n            line.split_whitespace()\n                .map(|n| {\n                    n.parse::<i32>()\n                        .map_err(Error::CouldNotParseNumber)\n                })  \n                .collect::<Result<Vec<_>>>()\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let extrapolations = input\n        .iter()\n        .map(|row| extrapolate_value(row))\n        .collect::<Result<Vec<_>>>()?;\n\n    let sum = extrapolations.iter().sum();\n\n    Ok(sum)\n}\n```\n\n### Part 2\n\nI half expected part 2 to be another maths thing like [yesterday](https://zoeaubert.me/blog/advent-of-code-2023-day-08/), but no, this was a nice simple twist. Rather than extrapolating forwards, we need to extrapolate backwards. The only change needed was to `extrapolate_value` which operated on the first rather than last elements in the arrays and inserted the value at the start rather than the end.\n\n```rust\nfn extrapolate_value(input: &[i32]) -> Result<i32> {\n    let mut values = vec![input.to_vec()];\n\n    loop {\n        let bottom = values\n            .last()\n            .ok_or_else(|| Error::CouldNotGetBottomRowOfValues)?;\n\n        if bottom.iter().all(|n| *n == 0) {\n            break;\n        }\n\n        values.push(calculate_differences(bottom));\n    }\n\n    for row_index in (0..values.len() - 1).rev() {\n        let row_last_value = values[row_index]\n            .first()\n            .ok_or_else(|| Error::CouldNotGetFirstValueOfRow(row_index))?;\n\n        let row_below_last_value = values[row_index + 1]\n            .first()\n            .ok_or_else(|| Error::CouldNotGetFirstValueOfRow(row_index + 1))?;\n\n        let next_value = row_last_value - row_below_last_value;\n\n        values[row_index].insert(0, next_value);\n    }\n\n    Ok(values[0][0])\n}\n```\n\n## Optimisation\n\nThere might be some neat maths trick I don't know about, but I can't see any algorithmic thing I can do to optimise this in any meaningful way.\n\n## Thoughts\n\nToday was a nice easy puzzle compared to some of the other days this week. It's nice to have an easy solution to an easy problem. Though it makes me worry about tomorrow 🤣\n\n## Results\n\n```\nday_09    fastest       │ slowest       │ median        │ mean\n├─ part1  311.9 µs      │ 405.2 µs      │ 313.6 µs      │ 316.4 µs\n╰─ part2  319.9 µs      │ 338.9 µs      │ 321 µs        │ 322.8 µs \n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-08": {
      "key": "advent-of-code-2023-day-08",
      "permalink": "/blog/advent-of-code-2023-day-08",
      "title": "Advent of Code 2023 - Day 08",
      "date": "2023-12-08T23:20:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 08. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-08) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday saw us taking a series of `Node`s with left and right children, and based on a series of instructions, take either the left or right children until we reach a goal node. The nodes were formatted like this:\n\n```\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\n```\n\nUsing this it was relatively easy to parse the `Node`s and build up a map of `Node`s.\n\n```rust\nstruct Node {\n    id: u32,\n    left: u32,\n    right: u32,\n}\n\nimpl Node {\n    fn new(id: u32, left: u32, right: u32) -> Self {\n        Self { id, left, right }\n    }\n\n    fn from_str(input: &str) -> Result<Self> {\n        let id = input\n            .get(0..=2)\n            .ok_or_else(|| Error::CouldNotFindIdForInstruction(input.to_string()))?;\n\n        let left = input\n            .get(7..=9)\n            .ok_or_else(|| Error::CouldNotFindLeftInstruction(input.to_string()))?;\n\n        let right = input\n            .get(12..=14)\n            .ok_or_else(|| Error::CouldNotFindRightInstruction(input.to_string()))?;\n\n        Ok(Self::new(\n            letters_to_id(id)?,\n            letters_to_id(left)?,\n            letters_to_id(right)?,\n        ))\n    }\n}\n\nstruct Map {\n    nodes: HashMap<u32, Node>,\n}\n\nimpl Map {\n    fn new(nodes: Vec<Node>) -> Self {\n        let mut map = Self {\n            nodes: HashMap::new(),\n        };\n\n        for node in nodes {\n            map.nodes.insert(node.id, node);\n        }\n\n        map\n    }\n\n    fn from_str(input: &str) -> Result<Self> {\n        let mut nodes = Vec::new();\n\n        for line in input.lines() {\n            nodes.push(Node::from_str(line)?);\n        }\n\n        Ok(Self::new(nodes))\n    }\n    \n    fn get_node(&self, id: u32) -> Result<&Node> {\n        self.nodes\n            .get(&id)\n            .ok_or_else(|| Error::CouldNotInspectionForId(id_to_letters(id)))\n    }\n}\n```\n\nI've opted to use a [HashMap](https://en.wikipedia.org/wiki/Hash_table) as it's the quickest way to look up `Node`s. You will notice that I've used `HashMap<u32, Node>` rather than `HashMap<String, Node>`. I don't know if this is still true but a fixed-size key is supposed to be a lot better than a String. As a result, I did some trickery.\n\n```rust\nconst ZZZ_ID: u32 = 0x005A5A5A;\n\nfn letters_to_id(letters: &str) -> Result<u32> {\n    if letters.len() != 3 {\n        return Err(Error::InvalidNumberOfLettersForId(letters.to_string()));\n    }\n\n    let mut id: u32 = 0;\n\n    for (i, letter) in letters.chars().rev().enumerate() {\n        id |= (letter as u32) << (i * 8);\n    }\n\n    Ok(id)\n}\n\nfn id_to_letters(id: u32) -> String {\n    let mut letters = String::new();\n\n    let letter_1 = ((id & 0x00FF0000) >> 16) as u8 as char;\n    let letter_2 = ((id & 0x0000FF00) >> 8) as u8 as char;\n    let letter_3 = (id & 0x000000FF) as u8 as char;\n\n    letters.push(letter_1);\n    letters.push(letter_2);\n    letters.push(letter_3);\n\n    letters\n}\n```\n\nThese functions convert the `Node` to and from a `u32`. Because I know that the `Node` IDs are always three-letter [ASCII](https://en.wikipedia.org/wiki/ASCII) characters, and I know that an ASCII character takes up 1 byte, I can store all three in a `u32` without much difficulty. For example, the `Node` ID `ABC` will be encoded as `0x00414243` in [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal). \n\nFrom here it's a simple task to follow the instructions and traverse the `Node` `Map` until we find the `Node` we want. The instructions are given as a list of `L` and `R` (for each child `Node`). If you reach the end of the instructions and have not reached your goal `Node`, you repeat the instructions as required.\n\n```rust\npub fn process(input: &str) -> Result<u32> {\n    let mut lines = input.lines().map(|l| l.trim());\n\n    let instructions = lines.next().ok_or_else(|| Error::NoInstructionsFound)?;\n\n    lines.next();\n\n    let remaining = lines.collect::<Vec<_>>().join(\"\\n\");\n\n    let map = Map::from_str(&remaining)?;\n\n    let mut steps = 0;\n    let mut current_node = map.get_node(letters_to_id(\"AAA\")?)?;\n\n    loop {\n        for direction in instructions.chars() {\n            if current_node.id == ZZZ_ID {\n                return Ok(steps);\n            }\n\n            match direction {\n                'L' => current_node = map.get_node(current_node.left)?,\n                'R' => current_node = map.get_node(current_node.right)?,\n                _ => return Err(Error::UnexpectedInstruction(direction.to_string())),\n            }\n\n            steps += 1;\n        }\n    }\n}\n```\n\n### Part 2\n\nPart 2 saw the fun introduction of instead of starting at the `Node` with the ID `AAA`, we're required to start at any `Node` ending with `A` and finish at any `Node` finishing with `Z`. For all the start `Node`s, we must work out what is the minimum number of steps required before all \"walks\" (the word I'm going to use to represent the journey from a start to end `Node` when following the instructions) are on a `Node` ending with `Z`.\n\nOh, boi. This really complicates things. Working out when two \"walks\" both hit an end `Node` at the same time is kinda hard. I think [the problem](https://adventofcode.com/2023/day/8) describes it pretty well.\n\n```\nLR\n\n11A = (11B, XXX)\n11B = (XXX, 11Z)\n11Z = (11B, XXX)\n22A = (22B, XXX)\n22B = (22C, 22C)\n22C = (22Z, 22Z)\n22Z = (22B, 22B)\nXXX = (XXX, XXX)\n```\n\n```\nHere, there are two starting nodes, `11A` and `22A` (because they both end with `A`). As you follow each left/right instruction, use that instruction to _simultaneously_ navigate away from both nodes you're currently on. Repeat this process until _all_ of the nodes you're currently on end with `Z`. (If only some of the nodes you're on end with `Z`, they act like any other node and you continue as normal.) In this example, you would proceed as follows:\n\n- Step 0: You are at `11A` and `22A`.\n- Step 1: You choose all of the _left_ paths, leading you to `11B` and `22B`.\n- Step 2: You choose all of the _right_ paths, leading you to `_11Z_` and `22C`.\n- Step 3: You choose all of the _left_ paths, leading you to `11B` and `_22Z_`.\n- Step 4: You choose all of the _right_ paths, leading you to `_11Z_` and `22B`.\n- Step 5: You choose all of the _left_ paths, leading you to `11B` and `22C`.\n- Step 6: You choose all of the _right_ paths, leading you to `_11Z_` and `_22Z_`.\n\nSo, in this example, you end up entirely on nodes that end in `Z` after `_6_` steps.\n```\n\nIt was at this point I suspected that cycles would be important. I was ultimately right, but not before I went down a weird path.\n\nI noticed in this example that the path the first walk takes loops every 2 steps. But this felt like a trap. What if there was a walk that didn't directly repeat, but instead oscillated between two valid end `Node`s? Thinking that this was likely to be a gotcha, I set about solving it with this problem in mind.\n\nI've recently been watching a bunch of videos on [ray marching](https://en.wikipedia.org/wiki/Ray_marching) and thought I could borrow the approach. Essentially, it works out the longest \"safe\" distance a ray can progress before it _might_ encounter an object. Using similar logic. I built a function that took a `Node`, the current input, and returned how many steps it had before it reached the next end `Node`. If I did this for all active walks, I would be able to skip forward to the next ending spot before progressing.\n\nI thought this approach was clever. I thought I'd got one up on the inevitable gotcha. But I was wrong. After letting it run for a long time and not getting a result of use, I investigated more. I logged the length of each walk to work out their cycle lengths and noticed that even when crossing their looping point, the lengths did not change. This disproved my theory and meant I needed to rethink my approach.\n\nIntroducing the [least/lowest common multiple](https://en.wikipedia.org/wiki/Least_common_multiple). I've seen a fair bit of discussion talking about how people don't understand why it works. I'm going to give it my best shot of explaining it.\n\n#### Why LCM works\n\nGiven two numbers, the LCM will tell you the first common multiple of two (or more) numbers. A \"common multiple\" is a number in which two other numbers can be multiplied by both arrive at. Let's take 2 and 3 and have a look at their multiples.\n\n```\n2: 02, 04, 06, 08, 10, 12, 14, 16, 18, 20\n3: 03, 06, 09, 12, 15, 18, 21, 24, 27, 30\n```\n\nWhen we look at this list of multiples, we can see that `06` is the first number that appears in both lists. It is _common_ to both lists of _multiples_. And because it is first, it is the _least_ common multiple.\n\nWe can apply this to our problem using the lengths of our cycles. If we consider the first walk, it hits an \"end\" `Node` every n steps equal to the cycle length. Which in this case is 2. If we listed the step/iteration count at the end of each of these cycles, it would look like `02, 04, 06, ...`, which is the same as our list of multiples from before. The same will be true with the other cycle with a length of 3.\n\nSo, if each of these \"multiples\" is equivalent to a cycle, we need to know when both cycles have ended at the same time. Or, another way of putting, that they have a step in common. \n\nIn this case, it's trivial, but in the actual input, the cycle lengths are:\n```\n[\n    17621,\n    13939,\n    12361,\n    19199,\n    15517,\n    20777,\n]\n```\n\nIf we take just the first two numbers. When would they both have a step in common? If you were to list every single multiple of `17,621` and `13, 939` below 1 million, you wouldn't find a common/shared multiple until `933,913`. And as you can imagine, this is much easier to compute than actually checking all the numbers before that.\n\nThis also gets out of hand pretty quickly. If you take the first three walks, the LCM is `43,893,911`. Adding that one number has made the search space increase by 47x. All of them together lead to a 14-digit number, which is crazy high and would take forever to check by hand. But this technique is much faster.\n\n#### Implementing LCM\n\nAs part of my misstep earlier, I built a lot of helper functions and structures.\n\n```rust\nstruct Input {\n    input: String,\n    cursor: usize,\n}\n\nimpl Input {\n    fn new(input: &str) -> Self {\n        Self {\n            input: input.to_string(),\n            cursor: 0,\n        }\n    }\n\n    fn skip(&mut self, n: usize) {\n        self.cursor += n;\n        self.cursor %= self.input.len();\n    }\n\n    fn peek(&self) -> Option<char> {\n        self.input.chars().nth(self.cursor)\n    }\n\n    fn next(&mut self) -> Option<char> {\n        let next = self.peek();\n        self.cursor += 1;\n        self.cursor %= self.input.len();\n        next\n    }\n}\n\nfn get_next_node(map: &Map, node: u32, mut input: Input) -> Result<(u32, Input)> {\n    let node = map.get_node(node)?;\n\n    match input.next() {\n        Some('L') => Ok((map.get_node(node.left)?.id, input)),\n        Some('R') => Ok((map.get_node(node.right)?.id, input)),\n        Some(c) => Err(Error::UnexpectedInstruction(c.to_string())),\n        None => Err(Error::UnexpectedEndOfInstructions),\n    }\n}\n\nfn steps_to_next_ending_in_z(map: &Map, node: u32, mut input: Input) -> Result<u64> {\n    let mut steps = 0;\n    let mut current_node = node;\n\n    loop {\n        if id_ends_with_z(current_node) {\n            return Ok(steps);\n        }\n\n        let (next_node, next_input) = get_next_node(map, current_node, input)?;\n\n        steps += 1;\n\n        current_node = next_node;\n        input = next_input;\n    }\n}\n\nfn lcm(numbers: &[u64]) -> u64 {\n    let mut result = numbers[0];\n\n    for &number in numbers.iter().skip(1) {\n        result = result * number / result.gcd(number);\n    }\n\n    result\n}\n```\n\nThe `Input` struct is definitely over-engineered. But it did make the \"repeat the instructions if not at the end until you are\" part much easier to work with.\n\nWith those it was pretty easy to calculate the cycle length (distance to first \"end\" `Node`) and then get the LCM of them\n\n```rust\npub fn process(input: &str) -> Result<u64> {\n    let mut lines = input.lines().map(|l| l.trim());\n\n    let instructions = lines.next().ok_or_else(|| Error::NoInstructionsFound)?;\n\n    let input = Input::new(instructions);\n\n    lines.next();\n\n    let remaining = lines.collect::<Vec<_>>().join(\"\\n\");\n\n    let map = Map::from_str(&remaining)?;\n\n    let current_nodes = map\n        .get_starting_nodes()\n        .iter()\n        .map(|n| n.id)\n        .collect::<Vec<_>>();\n\n    let distances_to_next_z = current_nodes\n        .par_iter()\n        .map(|n| steps_to_next_ending_in_z(&map, *n, input.clone()))\n        .collect::<Result<Vec<_>>>()?;\n\n    let lcm: u64 = lcm(&distances_to_next_z);\n\n    Ok(lcm)\n}\n```\n\n## Optimisation\n\nI don't think there's anything you could optimise out here. Maybe there is though and it'd be fun to be corrected.\n\n## Thoughts\n\nI was not a fan of today. Not because it wasn't a good puzzle but because it required knowing and understanding how to apply a maths concept, rather than a computer science concept. I don't mind it when [Project Euler](https://projecteuler.net/) does it, because that's a maths sort of problem set, but I disliked it here. I like using programming challenges to teach and many people are (rightly) put off by the heavy maths stuff so I have to point them to other places. I hoped this would be more maths-light.\n\n## Results\n\n```\nday_08    fastest       │ slowest       │ median        │ mean\n├─ part1  351.7 µs      │ 1.896 ms      │ 381.9 µs      │ 441.9 µs\n╰─ part2  1.096 ms      │ 8.691 ms      │ 1.169 ms      │ 1.355 ms \n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-07": {
      "key": "advent-of-code-2023-day-07",
      "permalink": "/blog/advent-of-code-2023-day-07",
      "title": "Advent of Code 2023 - Day 07",
      "date": "2023-12-07T14:40:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 07. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-07) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday saw us implementing \"Camel Cards\" or TotallyNotPoker™️. Though to be fair, it is a much simpler version of the game, though I see how it'd be easy to play while riding a camel 🤣.\n\nRather than me explaining all the rules, I suggest you read [the problem](https://adventofcode.com/2023/day/7). This is possibly the easiest to understand so far.\n\nAs soon as I saw the problem, I knew how I wanted to build it, and it's taking advantage of some of the really nice things from Rust.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]\nenum Card {\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace,\n}\n\nimpl Card {\n    fn from_str(input: char) -> Result<Self> {\n        match input {\n            'A' => Ok(Self::Ace),\n            'K' => Ok(Self::King),\n            'Q' => Ok(Self::Queen),\n            'J' => Ok(Self::Jack),\n            'T' => Ok(Self::Ten),\n            '9' => Ok(Self::Nine),\n            '8' => Ok(Self::Eight),\n            '7' => Ok(Self::Seven),\n            '6' => Ok(Self::Six),\n            '5' => Ok(Self::Five),\n            '4' => Ok(Self::Four),\n            '3' => Ok(Self::Three),\n            '2' => Ok(Self::Two),\n            _ => Err(Error::CouldNotParseCard(input.to_string())),\n        }\n    }\n}\n```\n\nWe're into the fun stuff already. `Card` \"derives\" `Ord`. `Ord` is a way of representing the relative ordering of two values, essentially `>, <, =`. Using this very simple `derive`, `Card`s can now be easily compared without having to hold an internal value to compare against. The order is given ascending in the order it's defined.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Ord, PartialOrd, Hash)]\nenum HandType {\n    HighCard,\n    OnePair,\n    TwoPair,\n    ThreeOfAKind,\n    FullHouse,\n    FourOfAKind,\n    FiveOfAKind,\n}\n\nimpl HandType {\n    fn from_cards(cards: &[Card]) -> Result<Self> {\n        if cards.len() != 5 {\n            return Err(Error::UnexpectedNumberOfCards);\n        }\n\n\t\t// Sort asc\n        let mut cards = cards.to_vec();\n        cards.sort();\n\n\t\t// Cards 0-4 must all be the same\n        if cards[0] == cards[4] {\n            return Ok(HandType::FiveOfAKind);\n        }\n\n\t\t// Cards 0-3 or 1-4 must all be the same\n        if cards[0] == cards[3] || cards[1] == cards[4] {\n            return Ok(HandType::FourOfAKind);\n        }\n\n        // Three of a kind and a pair\n        if (cards[0] == cards[2] && cards[3] == cards[4])\n            || (cards[0] == cards[1] && cards[2] == cards[4])\n        {\n            return Ok(HandType::FullHouse);\n        }\n\n        // Groups of threes\n        if cards[0] == cards[2] || cards[1] == cards[3] || cards[2] == cards[4] {\n            return Ok(HandType::ThreeOfAKind);\n        }\n\n        if (cards[0] == cards[1] && cards[2] == cards[3])\n            || (cards[0] == cards[1] && cards[3] == cards[4])\n            || (cards[1] == cards[2] && cards[3] == cards[4])\n        {\n            return Ok(HandType::TwoPair);\n        }\n\n        if cards[0] == cards[1]\n            || cards[1] == cards[2]\n            || cards[2] == cards[3]\n            || cards[3] == cards[4]\n        {\n            return Ok(HandType::OnePair);\n        }\n\n        Ok(HandType::HighCard)\n    }\n}\n```\n\nNext was determining the `Hand` \"type\". Similar to last time, we get the comparison for free. The complexity is introduced here in determining what hand we actually have. \n\nThanks to `Card` being `Ord` we can call sort on a vector of them and get the cards sorted. Sorting them is important as it allows us to make quick comparisons to determine the hand. For example, if `card[0]` and `card[4]` are the same, then every value between them must also be the same. Therefore, we know that all five cards must be the same, giving us five of a kind.\n\nWe can then expand this logic to cover each case. It gets more complex, but hopefully, it's followable. Most of it is taking a \"window\" of x number of cards and seeing if any of them meet the equality requirement. The only weird one is full-house, which has to check for three of a kind and a pair in two different ways.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nstruct Hand {\n    cards: [Card; 5],\n    hand_type: HandType,\n}\n\nimpl Hand {\n    fn new(cards: [Card; 5]) -> Result<Self> {\n        let hand_type = HandType::from_cards(&cards)?;\n        \n        Ok(Self { cards, hand_type })\n    }\n\n    fn from_str(input: &str) -> Result<Self> {\n        let mut cards = [Card::Two; 5];\n        for (i, card) in input.chars().enumerate() {\n            cards[i] = Card::from_str(card)?;\n        }\n        Self::new(cards)\n    }\n}\n```\n\nWe can then make a `Hand` containing the `Card`s and their corresponding `HandType`. We're going to want to compare `Hand`s, but you might've noticed we've not `derive`d `Ord`. That's because we need to do something a bit more clever here so we're going to implement it ourselves.\n\n```rust\nimpl Ord for Hand {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n\t    // Compare the HandType\n        match self.hand_type.cmp(&other.hand_type) {\n\t        // If the two hands have the same HandType\n            std::cmp::Ordering::Equal => {\n\t            // zip takes two arrays and allows you to iterate through them at the same time without having to do index stuff\n                for (self_card, other_card) in self.cards.iter().zip(other.cards.iter()) {\n\t                // Compare the face value of the Card\n                    match self_card.cmp(other_card) {\n\t                    // If equal, keep going\n                        std::cmp::Ordering::Equal => continue,\n                        // If they're different, return the result of the face value comparison\n                        other => return other,\n                    }\n                }\n                // Default to equal\n                std::cmp::Ordering::Equal\n            }\n            // If HandType is not equal, return the HandType comparison\n            other => other,\n        }\n    }\n}\n\n// We need PartialOrd to satisfy other constraints, but it can just use `Ord`\nimpl PartialOrd for Hand {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n```\n\nI've added a bunch of comments here to hopefully explain what this is doing. It might be a bit much if you've not seen Rust before. Essentially, we check if the two `Hand`s have different `HandTypes`. If they're different, return the ordering for that. If they're the same, we then compare each `Card` in the hands until it breaks the tie.\n\nWith that, we can now sort out hands.\n\n```rust\nfn order_hands(hands: &[Hand]) -> Vec<Hand> {\n    let mut hands = hands.to_vec();\n    hands.sort();\n    hands\n}\n```\n\nNext, we need to store the `HandAndBet` and be able to compare them, too.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nstruct HandAndBet {\n    hand: Hand,\n    bet: u32,\n}\n\nimpl HandAndBet {\n    fn from_str(input: &str) -> Result<Self> {\n        let mut split = input.split_whitespace();\n\n        let hand = split\n            .next()\n            .ok_or_else(|| Error::CouldNotParseHandAndBet(input.to_string()))?;\n\n        let hand = Hand::from_str(hand)?;\n\n        let bet = split\n            .next()\n            .ok_or_else(|| Error::CouldNotParseHandAndBet(input.to_string()))?\n            .parse::<u32>()\n            .map_err(Error::CouldNotParseNumber)?;\n\n        Ok(Self { hand, bet })\n    }\n}\n\nimpl Ord for HandAndBet {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n\t    // We don't care about the value of bet so just pass through the comparison of hand\n        self.hand.cmp(&other.hand)\n    }\n}\n\nimpl PartialOrd for HandAndBet {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n\nfn sort_hands_and_bets(hands_and_bets: &[HandAndBet]) -> Vec<HandAndBet> {\n    let mut hands_and_bets = hands_and_bets.to_vec();\n    hands_and_bets.sort();\n    hands_and_bets\n}\n```\n\nAnd with that, we can now sort `HandAndBet`. All that's left is then to take these sorted `HandAndBet`s, and multiply their bet by their rank and return the sum.\n\n```rust\npub fn process(input: &str) -> miette::Result<u32> {\n    let bets_and_hands = input\n        .lines()\n        .map(|line| HandAndBet::from_str(line.trim()))\n        .collect::<Result<Vec<HandAndBet>>>()?;\n\n    let ordered_hands_and_bets = sort_hands_and_bets(&bets_and_hands);\n\n    let total_winnings = ordered_hands_and_bets\n        .iter()\n        .enumerate()\n        .map(|(i, hand_and_bet)| hand_and_bet.bet * (i + 1) as u32)\n        .sum::<u32>();\n\n    Ok(total_winnings)\n}\n```\n\n### Part 2\n\nPart 2 was an obvious twist and made `J` represent a Joker rather than a Jack. Thankfully, because I over-engineered it the first time, it's not that hard to update it to work. \n\nFirst, we need to change `J` to be worth less than two.\n\n```rust\nenum Card {\n    Jack,\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Queen,\n    King,\n    Ace,\n}\n```\n\nThe only other change is to `HandType`, we need to make this account for Jokers. This is much more complex than before.\n\n```rust\nimpl HandType {\n    fn from_cards(cards: &[Card]) -> Result<Self> {\n        if cards.len() != 5 {\n            return Err(Error::UnexpectedNumberOfCards);\n        }\n\n\t\t// Sorted ascending\n        let mut cards = cards.to_vec();\n        cards.sort();\n\n        // Joker is always at start of hand\n\n        if cards[0] == cards[4] {\n            return Ok(HandType::FiveOfAKind);\n        }\n\n        let number_of_jokers = cards.iter().filter(|card| **card == Card::Jack).count();\n\n        match number_of_jokers {\n\t        // I don't believe this is necessary as the previous check should've got it, but I have it here for completeness\n            5 => Ok(HandType::FiveOfAKind),\n            \n            // If you have 4 Jokers, change all to be the only other card and get five of a kind\n            4 => Ok(HandType::FiveOfAKind),\n            \n            3 => {\n\t            // If the two other cards match, you can make all the Jokers that card\n                if cards[3] == cards[4] {\n                    return Ok(HandType::FiveOfAKind);\n                }\n\n\t\t\t\t// Change all the Jokers to one of the cards and get four of a kind\n                Ok(HandType::FourOfAKind)\n            }\n            \n            2 => {\n\t            // If the last 3 cards are all the same, you can make all the Jokers match\n                if cards[2] == cards[4] {\n                    return Ok(HandType::FiveOfAKind);\n                }\n                \n\t\t\t\t// If you have a pair, you can make four of a kind\n                if (cards[2] == cards[3]) || (cards[3] == cards[4]) {\n                    return Ok(HandType::FourOfAKind);\n                }\n\n\t\t\t\t// If you have nothing, you can always match the two jokers to one of the cards for three of a kind\n                Ok(HandType::ThreeOfAKind)\n            }\n            \n            1 => {\n\t            // If all other cards match, you can make the Joker match to make five of a kind\n                if cards[1] == cards[4] {\n                    return Ok(HandType::FiveOfAKind);\n                }\n\n\t\t\t\t// If you have three of a kind, you can use the joker to make four of a kind\n                if cards[1] == cards[3] || cards[2] == cards[4] {\n                    return Ok(HandType::FourOfAKind);\n                }\n\n\t\t\t\t// If you have two pairs, you can make the joker one of them and make a full house\n                if cards[1] == cards[2] && cards[3] == cards[4] {\n                    return Ok(HandType::FullHouse);\n                }\n\n\t\t\t\t// If you hav a pair, you can make three of a kind\n                if cards[1] == cards[2] || cards[2] == cards[3] || cards[3] == cards[4] {\n                    return Ok(HandType::ThreeOfAKind);\n                }\n\n                Ok(HandType::OnePair)\n            }\n\n\t\t\t// Same as in part 1\n            0 => {\n                if cards[0] == cards[3] || cards[1] == cards[4] {\n                    return Ok(HandType::FourOfAKind);\n                }\n\n                if (cards[0] == cards[2] && cards[3] == cards[4])\n                    || (cards[0] == cards[1] && cards[2] == cards[4])\n                {\n                    return Ok(HandType::FullHouse);\n                }\n\n                if cards[0] == cards[2] || cards[1] == cards[3] || cards[2] == cards[4] {\n                    return Ok(HandType::ThreeOfAKind);\n                }\n\n                if (cards[0] == cards[1] && cards[2] == cards[3])\n                    || (cards[0] == cards[1] && cards[3] == cards[4])\n                    || (cards[1] == cards[2] && cards[3] == cards[4])\n                {\n                    return Ok(HandType::TwoPair);\n                }\n\n                if cards[0] == cards[1]\n                    || cards[1] == cards[2]\n                    || cards[2] == cards[3]\n                    || cards[3] == cards[4]\n                {\n                    return Ok(HandType::OnePair);\n                }\n\n                Ok(HandType::HighCard)\n            }\n            _ => Err(Error::UnexpectedNumberOfCards),\n        }\n    }\n}\n```\n\nThis is kinda similar to the previous implementation, but the `Card` lookup has to first consider how many Jokers there are so it can use them. Again, thanks to it being sorted we can make a lot of assumptions that simplify things immensely.\n\nNo other changes were necessary to make this work. Over-engineering wins again.\n\n## Optimisation\n\nThere are no obvious optimisations that I think would save any significant time. No matter what you do you still need to rank every hand which requires sorting. And I'm not doing anything too crazy with the cards -> hand-type mapping.\n\nI did try multi-threading for part 1, but unsurprisingly it made things slower.\n\n## Thoughts\n\nThis was cool and didn't have any major complications. I've always meant to build a poker game thing, so this was a good practice and proof of concept.\n\n## Results\n\n```\nday_07        fastest       │ slowest       │ median        │ mean\n├─ part1      154.9 µs      │ 251.2 µs      │ 169.4 µs      │ 172.7 µs \n├─ part1_opt  134.7 µs      │ 578.2 µs      │ 211.4 µs      │ 236.7 µs\n╰─ part2      173.6 µs      │ 207.4 µs      │ 174.7 µs      │ 178.3 µs \n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-06": {
      "key": "advent-of-code-2023-day-06",
      "permalink": "/blog/advent-of-code-2023-day-06",
      "title": "Advent of Code 2023 - Day 06",
      "date": "2023-12-06T11:00:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 06. I optimised part 2 down to ~420ns. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-06) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday was much nicer than yesterday's. We were tasked with working out the optimal strategy for boat racing. A race lasts an amount of milliseconds (very short races) and has a record distance. For your boat to move, you must charge it. For every millisecond you charge it the boat goes 1 mm/s faster (it never slows down). Then, for any given race, you need to work out how many milliseconds to charge for in order to beat the record before the race ends.\n\nThe input was a series of time and distance pairs, each representing a race.\n\n```\nTime:      7  15   30\nDistance:  9  40  200\n```\n\nParsing this was pretty simple.\n\n```rust\nstruct Race {\n    time: u64,\n    distance: u64,\n}\n\nfn numbers_from_line(input: &str) -> Result<Vec<u64>> {\n    let colon_split: Vec<&str> = input.split(\": \").collect();\n\n    colon_split[1]\n        .split(' ')\n        .filter(|s| !s.is_empty())\n        .map(|s| s.parse::<u64>().map_err(Error::CouldNotParseNumber))\n        .collect()\n}\n\nfn input_to_races(input: &str) -> Result<Vec<Race>> {\n    let mut races = vec![];\n\n    let lines: Vec<&str> = input.split('\\n').map(|l| l.trim()).collect();\n\n    let times = numbers_from_line(lines[0])?;\n    let distances = numbers_from_line(lines[1])?;\n\n    for (i, time) in times.iter().enumerate() {\n        match distances.get(i) {\n            Some(distance) => races.push(Race {\n                time: *time,\n                distance: *distance,\n            }),\n            None => return Err(Error::MissingDistance(i)),\n        }\n    }\n\n    Ok(races)\n}\n```\n\nThe puzzle is to determine how many ways you can beat each race and then multiply them together.\n\n```rust\nfn calculate_max_distance_for_time(press_down_time: u64, max_time: u64) -> u64 {\n    let time_remaining = max_time - press_down_time;\n    time_remaining * press_down_time\n}\n\nfn number_of_ways_to_beat_race(race: &Race) -> u64 {\n    (0..race.time)\n        .map(|t| calculate_max_distance_for_time(t, race.time))\n        .filter(|t| t > &race.distance)\n        .count() as u64\n}\n\npub fn process(input: &str) -> miette::Result<u64> {\n    let races = input_to_races(input)?;\n\n    Ok(races.iter().map(number_of_ways_to_beat_race).product())\n}\n```\n\nAnd that's it. Compared to previous challenges, this is nice, small and very clean.\n\n### Part 2\n\nBased on [yesterday](https://zoeaubert.me/blog/advent-of-code-2023-day-05/) I had a funny feeling that they'd make the numbers very big. And they did. Rather than the input being multiple races, it's a single race and you need to ignore the spaces. The new race is:\n\n```\nTime:      71530\nDistance:  940200\n```\n\nThis number's still pretty small, let's see if it works without optimising.\n\n```rust\npub fn process(input: &str) -> miette::Result<u64> {\n    let races = input_to_races(input)?;\n\n    Ok(races.iter().map(number_of_ways_to_beat_race).product())\n}\n```\n\nIt worked, and it didn't take the lifetime of the universe. Nice. But I know we can do better.\n\n## Optimisation\n\nThere's one obvious optimisation here, and I _think_ they're even trying to hint at it in the statement.\n\n> Since the current record for this race is `9` millimetres, there are actually `_4_` different ways you could win: you could hold the button for `2`, `3`, `4`, or `5` milliseconds at the start of the race.\n\n> In the second race, you could hold the button for at least `4` milliseconds and at most `11` milliseconds and beat the record, a total of `_8_` different ways to win.\n\nFor each race, the only number that matters is the first and last charging time that'd beat the record. You know everything outside that range will lose, and anything inside that range will win.\n\nYou could search from each end to find the values, but I think [bisectional search](https://en.wikipedia.org/wiki/Binary_search_algorithm) lends itself much better to this problem, especially knowing how large the input is. Thanks to the way I've built it, it only requires changing `number_of_ways_to_beat_race`.\n\n```rust\nfn find_first_winning_number(race: &Race) -> u64 {\n    let mut low = 0;\n    let mut high = race.time;\n\n    loop {\n        let index = (low + high) / 2;\n        let left = index - 1;\n\n        let distance = calculate_max_distance_for_time(index, race.time);\n        let left_distance = calculate_max_distance_for_time(left, race.time);\n\n        if distance > race.distance && left_distance <= race.distance {\n            return index;\n        }\n\n        if distance <= race.distance {\n            low = index;\n        } else {\n            high = index;\n        }\n    }\n}\n\nfn find_last_winning_number(race: &Race) -> u64 {\n    let mut low = 0;\n    let mut high = race.time;\n\n    loop {\n        let index = (low + high) / 2;\n        let right = index + 1;\n\n        let distance = calculate_max_distance_for_time(index, race.time);\n        let right_distance = calculate_max_distance_for_time(right, race.time);\n\n        if distance > race.distance && right_distance <= race.distance {\n            return index;\n        }\n\n        if distance > race.distance {\n            low = index;\n        } else {\n            high = index;\n        }\n    }\n}\n\nfn number_of_ways_to_beat_race(race: &Race) -> u64 {\n    find_last_winning_number(race) - find_first_winning_number(race)\n}\n```\n\nYes, I'm doing two separate searches for each edge of the winners. You could probably do it in one. I tried it, but it was far too messy, and I don't think it would be that much faster.\n\nI applied this to both parts and got a ~1.4x improvement on part 1 and a ~124,324x improvement on part 2. That bisectional search is really doing work on that second part.\n\nFor those who are curious or, like me, found the part 2 improvement suspicious, the tests are running with 41ns precision, and part 2 had 100 samples with 1600 iterations. The full [benchmarking output](https://github.com/GeekyAubergine/advent-of-code/blob/main/2023/benchmarks/all.txt) is available on GitHub.\n\n## Thoughts\n\nI'm very pleased with how quickly I saw the optimisation and how well it performed. Makes learning and practising the implementation almost worth it 🤣\n\n## Results\n\n```\nday_06        fastest       │ slowest       │ median        │ mean\n├─ part1      790.7 ns      │ 5.04 µs       │ 791.7 ns      │ 852.1 ns\n├─ part1_opt  541.3 ns      │ 1.786 µs      │ 551.7 ns      │ 584.3 ns\n├─ part2      48.88 ms      │ 75.92 ms      │ 50.14 ms      │ 50.93 ms\n╰─ part2_opt  387.7 ns      │ 424.1 ns      │ 403.3 ns      │ 403.6 ns\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-05": {
      "key": "advent-of-code-2023-day-05",
      "permalink": "/blog/advent-of-code-2023-day-05",
      "title": "Advent of Code 2023 - Day 05",
      "date": "2023-12-05T14:45:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 05. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-05) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nI don't really know how to explain today's challenge. I would highly recommend reading the [problem](https://adventofcode.com/2023/day/5) yourself. It saw us taking seeds and working out where to plant them. Seeds were given as an array.\n\n```\nseeds: 79 14 55 13\n```\n\nFrom there, you were given a series of `map`s to process the seeds. \n\n```\nseed-to-soil map:\n50 98 2\n52 50 48\n```\n\nThese are essentially transformers that act on the seeds' value. After applying a bunch of these you then took the minimum remaining value.\n\nAs this was going to require some funky parsing I built a custom input and cursor, much easier than traversing lines in an iterator.\n\n```rust\nstruct Input {\n    lines: Vec<String>,\n    cursor: usize,\n}\n\nimpl Input {\n    fn from_str(input: &str) -> Result<Input> {\n        let lines = input\n            .lines()\n            .map(|s| s.trim().to_string())\n            .collect::<Vec<_>>();\n\n        Ok(Input { lines, cursor: 0 })\n    }\n\n    fn peak(&self) -> Option<&String> {\n        self.lines.get(self.cursor)\n    }\n\n    fn next(&mut self) -> Result<&String> {\n        let next = self\n            .lines\n            .get(self.cursor)\n            .ok_or_else(|| Error::CannotFindNextLine(self.cursor));\n        self.cursor += 1;\n        next\n    }\n\n    fn to_string(&self) -> String {\n        self.lines.join(\"\\n\")\n    }\n}\n```\n\nFrom there, it was a simple case of parsing the data.\n\n```rust\ntype ParserOutput<T> = (T, Input);\n\nstruct Seeds {\n    seeds: Vec<u32>,\n}\n\nimpl Seeds {\n    fn from_input(mut input: Input) -> Result<ParserOutput<Seeds>> {\n        let first_line = input.next().map_err(|_| Error::CannotFindSeedsHeader)?;\n\n        if !first_line.starts_with(\"seeds:\") {\n            return Err(Error::CannotFindSeedsHeader);\n        }\n\n        let seeds = first_line\n            .split(':')\n            .last()\n            .ok_or_else(|| Error::CannotFindSeedsHeader)?\n            .split(' ')\n            .filter(|s| !s.is_empty())\n            .map(|s| s.trim().parse::<u32>().map_err(Error::CouldNotParseNumber))\n            .collect::<Result<Vec<_>>>()?;\n\n        Ok((Seeds { seeds }, input))\n    }\n}\n```\n\n```rust\nstruct Map {\n    mapped_values: HashMap<u32, u32>,\n}\n\nimpl Map {\n    fn from_input(mut input: Input) -> Result<ParserOutput<Map>> {\n        let mut mapped_values = HashMap::new();\n\n        if !input.next()?.ends_with(\"map:\") {\n            return Err(Error::CannotFindMapHeader);\n        }\n\n        while let Some(line) = input.peak() {\n            if line.is_empty() {\n                break;\n            }\n\n            let line = input.next()?;\n\n            let numbers = line\n                .split(' ')\n                .filter(|s| !s.is_empty())\n                .map(|s| s.trim().parse::<u32>().map_err(Error::CouldNotParseNumber))\n                .collect::<Result<Vec<_>>>()?;\n\n            if numbers.len() != 3 {\n                return Err(Error::UnexpectedNumberOfValuesForMap(line.to_string()));\n            }\n\n            let destination_start = numbers[0];\n            let source_start = numbers[1];\n            let range = numbers[2];\n\n            for i in 0..range {\n                let source = source_start + i;\n                let destination = destination_start + i;\n\n                mapped_values.insert(source, destination);\n            }\n        }\n\n        Ok((Map { mapped_values }, input))\n    }\n\n    fn get_mapped_value(&self, value: u32) -> u32 {\n        *self.mapped_values.get(&value).unwrap_or(&value)\n    }\n}\n```\n\nThere is a mistake here in `Map`, if you've already spotted it, nice, you probably suffered in a similar way, if not, stay tuned.\n\n```rust\nstruct Data {\n    seeds: Seeds,\n    seed_to_soil_map: Map,\n    soil_to_fertilizer_map: Map,\n    fertilizer_to_water_map: Map,\n    water_to_light_map: Map,\n    light_to_temperature_map: Map,\n    temparure_to_humity_map: Map,\n    humidity_to_location_map: Map,\n}\n\nimpl Data {\n    fn from_input(input: Input) -> Result<Data> {\n        let (seeds, mut input) = Seeds::from_input(input)?;\n        \n        input.next()?;\n\n        let (seed_to_soil_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (soil_to_fertilizer_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (fertilizer_to_water_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (water_to_light_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (light_to_temperature_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (temparure_to_humity_map, mut input) = Map::from_input(input)?;\n\n        input.next()?;\n\n        let (humidity_to_location_map, _) = Map::from_input(input)?;\n\n        Ok(Data {\n            seeds,\n            seed_to_soil_map,\n            soil_to_fertilizer_map,\n            fertilizer_to_water_map,\n            water_to_light_map,\n            light_to_temperature_map,\n            temparure_to_humity_map,\n            humidity_to_location_map,\n        })\n    }\n\n    fn seeds(&self) -> &Seeds {\n        &self.seeds\n    }\n\n    fn map_seed(&self, seed: u32) -> u32 {\n        let soil = self.seed_to_soil_map.get_mapped_value(seed);\n        let fertilizer = self.soil_to_fertilizer_map.get_mapped_value(soil);\n        let water = self.fertilizer_to_water_map.get_mapped_value(fertilizer);\n        let light = self.water_to_light_map.get_mapped_value(water);\n        let temperature = self.light_to_temperature_map.get_mapped_value(light);\n        let humidity = self.temparure_to_humity_map.get_mapped_value(temperature);\n        let location = self.humidity_to_location_map.get_mapped_value(humidity);\n\n        location\n    }\n}\n\npub fn process(input: &str) -> miette::Result<u32> {\n    let input = Input::from_str(input)?;\n\n    let data = Data::from_input(input)?;\n\n    let min_location = data\n        .seeds()\n        .seeds\n        .iter()\n        .map(|seed| data.map_seed(*seed))\n        .min()\n        .ok_or(Error::NoMinValue)?;\n\n    Ok(min_location)\n}\n```\n\nI'm processing all the `Map`s and then passing in a single seed at a time, passing it through each `Map` and then getting its new value.\n\nSo, at this point, I was feeling good. I very quickly arrived at the point of having the example input processed and correct. So I swapped it to use the actual input, and, well, nothing happened. My computer sat there and processed. I added some logging and saw that it had only processed one line of the first `Map` after a minute.\n\nIt was at this point I looked properly at the actual input and noticed the size of the numbers. This is where my folly was. The first mapping range is:\n\n```\n2328388605 1716277852 240111965\n```\n\nYes, that's right, it has 240,111,965 numbers. And that's just the first of many. Looking back through the code I noticed my mistake. In `Map`, I was building a [HashMap](https://en.wikipedia.org/wiki/Hash_table) of value -> mapped value. This is not good on something this size. Thankfully, because I'd over-engineered it, the only thing that needed changing was `Map`.\n\n```rust\nstruct MapRange {\n    destination_start: u64,\n    source_start: u64,\n    range: u64,\n}\n\nimpl MapRange {\n    fn new(destination_start: u64, source_start: u64, range: u64) -> Result<MapRange> {\n        Ok(MapRange {\n            destination_start,\n            source_start,\n            range,\n        })\n    }\n\n    fn contains_value(&self, value: u64) -> bool {\n        value >= self.source_start && value < self.source_start + self.range\n    }\n\n    fn map_value(&self, value: u64) -> u64 {\n        if !self.contains_value(value) {\n            return value;\n        }\n\n        let offset = value - self.source_start;\n        let destination = self.destination_start + offset;\n\n        destination\n    }\n}\n\nstruct Map {\n    mapped_ranges: Vec<MapRange>,\n}\n\nimpl Map {\n    fn from_input(mut input: Input) -> Result<ParserOutput<Map>> {\n        let mut mapped_ranges = Vec::new();\n\n        if !input.next()?.ends_with(\"map:\") {\n            return Err(Error::CannotFindMapHeader);\n        }\n\n        while let Some(line) = input.peak() {\n            if line.is_empty() {\n                break;\n            }\n\n            let line = input.next()?;\n\n            let numbers = line\n                .split(' ')\n                .filter(|s| !s.is_empty())\n                .map(|s| s.trim().parse::<u64>().map_err(Error::CouldNotParseNumber))\n                .collect::<Result<Vec<_>>>()?;\n\n            if numbers.len() != 3 {\n                return Err(Error::UnexpectedNumberOfValuesForMap(line.to_string()));\n            }\n\n            let destination_start = numbers[0];\n            let source_start = numbers[1];\n            let range = numbers[2];\n\n            let map_range = MapRange::new(destination_start, source_start, range)?;\n\n            mapped_ranges.push(map_range);            \n        }\n\n        Ok((Map { mapped_ranges }, input))\n    }\n\n    fn get_mapped_value(&self, value: u64) -> u64 {\n        self.mapped_ranges\n            .iter()\n            .find(|map_range| map_range.contains_value(value))\n            .map(|map_range| map_range.map_value(value))\n            .unwrap_or(value)\n    }\n}\n```\n\nRather than precomputing all the mappings (silly in hindsight), I now keep track of the ranges, and when asked for a value, I check if it's in the range, map it as necessary, or return the original value.\n\nThis small change fixed everything. The process now not only ran, but it was fast. For a change, my over-engineering saved me. Lets hope part 2 doesn't ruin all that.\n\n### Part 2\n\nIt ruined all that.\n\nPart two changed the game. Instead of the `seeds` input being a list of seeds, it's now a list of pairs describing the starting seed number and then x number of following seeds.\n\n```\nseeds: 2906961955 52237479 1600322402 372221628\n```\n\nSo, this went from 4 seeds to 424,459,107. And that's not the whole input. Oh boi.\n\nI thought about it initially but decided I couldn't eyeball and optimise without a full rewrite, so I did the only logical thing. I brute forced it.\n\nIntroducing [Rayon](https://github.com/rayon-rs/rayon), my beloved. tldr; it lets you parallelise iterators with almost zero changes. \n\n```rust\npub fn process(input: &str) -> miette::Result<u64> {\n    let input = Input::from_str(input)?;\n\n    let data = Data::from_input(input)?;\n\n    let min_location = data\n        .seeds()\n        .seeds\n        .par_iter()\n        .map(|seed| data.map_seed(*seed))\n        .min()\n        .ok_or(Error::NoMinValue)?;\n\n    Ok(min_location)\n}\n```\n\nThe only change here is `iter` -> `par_iter`, (Yes, this is one of the many reasons I love Rust and this library). I then changed the `Seeds` component to handle the pairings.\n\n```rust\nimpl Seeds {\n    #[tracing::instrument]\n    fn from_input(mut input: Input) -> Result<ParserOutput<Seeds>> {\n        let first_line = input.next().map_err(|_| Error::CannotFindSeedsHeader)?;\n\n        if !first_line.starts_with(\"seeds:\") {\n            return Err(Error::CannotFindSeedsHeader);\n        }\n\n        let seed_pairs = first_line\n            .split(':')\n            .last()\n            .ok_or_else(|| Error::CannotFindSeedsHeader)?\n            .split(' ')\n            .filter(|s| !s.is_empty())\n            .map(|s| s.trim().parse::<u64>().map_err(Error::CouldNotParseNumber))\n            .collect::<Result<Vec<_>>>()?;\n\n        let mut seeds = Vec::new();\n\n        for seed_pair in seed_pairs.chunks(2) {\n            let seed = seed_pair[0];\n            let count = seed_pair[1];\n\n            for i in 0..count {\n                seeds.push(seed + i);\n            }\n        }\n\n        Ok((Seeds { seeds }, input))\n    }\n}\n```\n\nAnd with that, we were off. It took my Apple M2 Max 7 minutes to compute, and used just shy of 16GB of RAM. Damn.\n\nThis is clearly not the right solution, but it worked so I won't lament it. Part of my taking part in this is to accept \"good enough\" solutions. At least before I optimise them\n\n## Optimisation\n\nI don't see any need to optimise part 1, or anywhere where I could make significant inroads.\n\nPart 2 needs revisiting. I've tried a few things but not finished them. If I do I will update this post. Things I've considered trying:\n- Working from the bottom up. We know the minimum locations, what if we worked backwards from that to get an input seed range?\n- Operate only on ranges. Change the seeds to ranges and apply the mappings that way.\n\n## Thoughts\n\nThis was good. Evil but good. Everyone I know was caught off guard by the sudden explosion in size either causing insane run-times and or out-of-memory errors everywhere. If this is a sign of things to come and it's only day five, I'm a little worried 🤣.\n\n## Results\n\n```\nday_05    fastest       │ slowest       │ median        │ mean\n├─ part1  57.2 µs       │ 370.5 µs      │ 62.06 µs      │ 79.74 µs\n╰─ part2 7 minutes\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-04": {
      "key": "advent-of-code-2023-day-04",
      "permalink": "/blog/advent-of-code-2023-day-04",
      "title": "Advent of Code 2023 - Day 04",
      "date": "2023-12-04T15:30:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 04. This post contains spoilers.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-04) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday saw us parsing [scratchcards](https://en.wikipedia.org/wiki/Scratchcard). \n\n```\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\n```\n\nEach card has a number, a set of winning numbers on the left of the `|` and the player's numbers on the right. In this case, this is card `1`, the winning numbers are `41 48 83 86 17` and the player's numbers are `83 86 6 31 1 7 9`. If the player has revealed a winning number, the card is worth `1` point, if the player reveals any more winning numbers it doubles for each additional winner. \n\nI started with a function to parse each line and extract the numbers from it. This is built around splitting and parsing. The code is pretty self-explanatory. The `ok_or` is for error handling to change `Option` (null) to an error.\n\n```rust\npub fn score_line(line: &str) -> Result<u32> {\n    let numbers = line\n        .split(':')\n        .last()\n        .ok_or(Error::CannotFindNumbers { line: 0 })?;\n\n    let mut numbers = numbers.split('|');\n\n    let winning_numbers = numbers\n        .next()\n        .ok_or(Error::CannotFindWinningNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let scratch_numbers = numbers\n        .last()\n        .ok_or(Error::CannotFindScratchedNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n}\n```\n\nFrom here, it's pretty easy to add the scoring part:\n\n```rust\npub fn score_line(line: &str) -> Result<u32> {\n    let numbers = line\n        .split(':')\n        .last()\n        .ok_or(Error::CannotFindNumbers { line: 0 })?;\n\n    let mut numbers = numbers.split('|');\n\n    let winning_numbers = numbers\n        .next()\n        .ok_or(Error::CannotFindWinningNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let scratch_numbers = numbers\n        .last()\n        .ok_or(Error::CannotFindScratchedNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let winning_scratched = winning_numbers\n        .iter()\n        .filter(|n| scratch_numbers.contains(n))\n        .count();\n\n    if winning_scratched == 0 {\n        return Ok(0);\n    }\n\n    Ok(1 << (winning_scratched - 1))\n}\n```\n\nThe \"worth one point and then doubling\" lent itself nicely to [bit shifting](https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift). This feels much neater than other solutions and doesn't require an additional loop. From there it was pretty easy to turn this into a full solution.\n\n```rust\npub fn process(input: &str) -> miette::Result<u32> {\n    let out = input\n        .lines()\n        .map(|line| score_line(line.trim()))\n        .collect::<Result<Vec<_>>>()\n        .map(|v| v.iter().sum())?;\n\n    Ok(out)\n}\n```\n\n### Part 2\n\nThe second part was much more interesting, rather than a card scoring points. For each winning number, it gave you a copy of the next `n` number of winning cards to scratch off. For example, card 1 has four winning numbers, so you get a copy of cards 2, 3, 4, and 5. This process then repeats for all of the player's cards. If you have multiple copies of a card, you play them all. For example, after winning a copy of card 2, you would play it twice, win twice, and get two additional copies of cards 3 and 4.\n\nTo keep track of the number of copies of each card the player has, the best solution is a [HashMap](https://en.wikipedia.org/wiki/Hash_table), as it allows quick indexing and modification by an index (card number).\n\n```rust\nstruct Cards {\n    copies: HashMap<u32, u32>,\n}\n\nimpl Cards {\n    fn new() -> Self {\n        Self {\n            copies: HashMap::new(),\n        }\n    }\n\n    fn add_card(&mut self, card: u32) {\n        *self.copies.entry(card).or_insert(0) += 1;\n    }\n\n    fn add_card_copies(&mut self, card: u32, copies: u32) {\n        *self.copies.entry(card).or_insert(0) += copies;\n    }\n\n    fn get_count(&self, card: u32) -> u32 {\n        *self.copies.get(&card).unwrap_or(&0)\n    }\n}\n```\n\nFrom there the code looks pretty similar bar the new way of scoring\n\n```rust\npub fn score_line(line: &str, mut cards: Cards) -> Result<Cards> {\n    let mut card_and_numbers = line.split(':');\n\n    let card_number = card_and_numbers\n        .next()\n        .ok_or_else(|| Error::CannotFindCardNumber(line.to_owned()))?\n        .split(' ')\n        .last()\n        .ok_or_else(|| Error::CannotFindCardNumber(line.to_owned()))?\n        .parse::<u32>()\n        .map_err(|_| Error::CouldNotParseCardNumber(line.to_owned()))?;\n\n\t// Add self for the original copy of card\n    cards.add_card(card_number);\n\n    let numbers = card_and_numbers\n        .last()\n        .ok_or(Error::CannotFindNumbers { line: 0 })?;\n\n    let mut numbers = numbers.split('|');\n\n    let winning_numbers = numbers\n        .next()\n        .ok_or(Error::CannotFindWinningNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let scratch_numbers = numbers\n        .last()\n        .ok_or(Error::CannotFindScratchedNumbers { line: 0 })?\n        .split(' ')\n        .filter(|n| !n.is_empty())\n        .map(|n| {\n            n.parse::<u32>()\n                .map_err(|_| Error::CouldNotParseNumber(n.to_string()))\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    let winning_scratched = winning_numbers\n        .iter()\n        .filter(|n| scratch_numbers.contains(n))\n        .count();\n\n    let copies = cards.get_count(card_number);\n\n    for i in 1..=winning_scratched {\n        cards.add_card_copies(card_number + i as u32, copies);\n    }\n\n    Ok(cards)\n}\n```\n\nNote that because this is going to be used in a `fold`(reduce) function, this function takes mutable ownership of `Cards` and returns the mutated copy rather than mutating by reference. There are ways to do it by reference, but this is much cleaner.\n\n```rust\npub fn process(input: &str) -> miette::Result<u32> {\n    let mut lines = input.lines();\n\n    let cards = lines.try_fold(Cards::new(), |cards, line| score_line(line.trim(), cards))?;\n\n    let card_count = input\n        .lines()\n        .enumerate()\n        .map(|(i, _line)| cards.get_count(i as u32 + 1))\n        .sum::<u32>();\n\n    Ok(card_count)\n}\n```\n\nI'm happy with this implementation as it feels clean and clear.\n\n## Optimisation\n\nAfter playing around with it for a bit, I only found one optimisation of use. Rather than using my previous technique for parsing numbers, I built a new function to do it:\n\n```rust\nfn parse_numbers(input: &str) -> Result<Vec<u32>> {\n    let input = input.trim();\n\n    let mut in_number = false;\n    let mut numbers = vec![];\n    let mut number_start = 0;\n\n    for (i, c) in input.chars().enumerate() {\n        if c.is_ascii_digit() {\n            if !in_number {\n                in_number = true;\n                number_start = i;\n            }\n        } else if in_number {\n            numbers.push(\n                input[number_start..i]\n                    .parse()\n                    .map_err(|_| Error::CouldNotParseNumber(input.to_string()))?,\n            );\n            in_number = false;\n        }\n    }\n\n    if in_number {\n        numbers.push(\n            input[number_start..]\n                .parse()\n                .map_err(|_| Error::CouldNotParseNumber(input.to_string()))?,\n        );\n    }\n\n    Ok(numbers)\n}\n\nfn score_line(line: &str) -> Result<u32> {\n    let numbers = line\n        .split(':')\n        .last()\n        .ok_or(Error::CannotFindNumbers { line: 0 })?;\n\n    let mut numbers = numbers.split('|');\n\n    let winning_numbers = numbers\n        .next()\n        .ok_or(Error::CannotFindWinningNumbers { line: 0 })?;\n\n    let winning_numbers = parse_numbers(winning_numbers)?;\n\n    let scratch_numbers = numbers\n        .last()\n        .ok_or(Error::CannotFindScratchedNumbers { line: 0 })?;\n\n    let scratch_numbers = parse_numbers(scratch_numbers)?;\n\n    let winning_scratched = winning_numbers\n        .iter()\n        .filter(|n| scratch_numbers.contains(n))\n        .count();\n\n    if winning_scratched == 0 {\n        return Ok(0);\n    }\n\n    Ok(1 << (winning_scratched - 1))\n}\n```\n\nDoing this yielded a ~1.4x improvement for both part 1 and part 2.\n\nI did try a few other things, including making `winning_numbers` a HashSet rather than an array, but the upfront cost seemed to contract any gains, which is expected on a data set of this size.\n\n## Results\n\n```\nday_04        fastest       │ slowest       │ median        │ mean\n├─ part1      157.9 µs      │ 213.4 µs      │ 164.9 µs      │ 167.3 µs\n├─ part1_opt  114.4 µs      │ 152.3 µs      │ 114.7 µs      │ 116.7 µs\n├─ part2      189.4 µs      │ 227.6 µs      │ 192.8 µs      │ 193.5 µs\n╰─ part2_opt  136.8 µs      │ 164.2 µs      │ 140.5 µs      │ 141.8 µs\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-03": {
      "key": "advent-of-code-2023-day-03",
      "permalink": "/blog/advent-of-code-2023-day-03",
      "title": "Advent of Code 2023 - Day 03",
      "date": "2023-12-03T14:55:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 03. This post contains spoilers. I also have a test case that might help you if you're stuck like I was.",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [day 01 post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-03) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n> Updated 07:40 2023-12-04 with part 1 optimisation\n\n## Initial solutions\n\n### Part 1\n\nToday saw us finding numbers adjacent to symbols and adding them up. Sounds pretty simple on paper, but this caused me some headaches. \n\nMy first headache came from trying to be clever too soon, and instead of doing \"numbers adjacent to symbols\", I did \"symbols adjacent to numbers\". This led to the rather funny issue where if two symbols touched the same number (for example, `.#545%.` ) it would get counted twice. It's not that big of an issue, and it was caught by the sample data.\n\nThen, the real fun began. I was stuck for a while with a solution that was wrong. Clearly, there was some bug not caught by the sample data but present in the larger data. I tried eyeballing it for a while, but it was too large to spot. So I ended up building a frankly ridiculous test.\n\n```rust\nfn it_should_extract_part_numbers_adjacent_to_symbol() -> miette::Result<()> {\n        let input = include_str!(\"../input1.txt\");\n\n        let part_numbers = input\n            .lines()\n            .enumerate()\n            .flat_map(|(i, line)| extract_part_numbers_from_line(line.trim(), i as u32))\n            .collect::<Vec<_>>();\n\n        let symbols = input\n            .lines()\n            .enumerate()\n            .flat_map(|(i, line)| extract_symbols_from_line(line.trim(), i as u32))\n            .collect::<Vec<_>>();\n\n        let parts_next_to_symbols = part_numbers_adaject_to_a_symbol(&part_numbers, &symbols);\n\n        let expect_part_numbers = vec![\n            155, 944, 622, 31, 264, 532, 254, 528, //line 1\n            111, 495, 558, //line 2\n            791, 62, 618, 818, 642, 789, //line 3\n            58, 405, 542, 587, 198, 846, 647, // line 4\n            964, 474, 302, 786, 43, 505, 436, 51, //line 5\n            832, 951, 984, 111, 198, 322, 186, 262, //line 6\n            490, 690, 346, 702, 566, 192, 190, 87, //line 7\n            816, 588, 152, 535, 425, 53, //line 8\n            36, 290, 831, 374, 579, 536, 733, 169, 146, 179, 658, 260, // line 9\n            795, 776, 790, 871, 281, // line 10\n            78, 716, 400, 319, 167, 399, 599, // line 11\n            719, 376, 800, 211, 478, 326, 93, 889, 684, 285, // line 12\n            852, 462, 374, 603, 369, // line 13\n            960, 966, 321, 925, 926, 947, // line 14\n            479, 909, 339, 17, 284, 657, 587, // line 15,\n            772, 345, 93, 465, 419, 676, 521, 399, 662, // line 16\n            17, 2, 531, 79, 589, 198, 734, 534, 614, // line 17\n            301, 321, 895, 344, 694, 717, 511, // line 18\n            707, 370, 428, 509, 889, 353, // line 19\n            973, 877, 855, 955, 670, 682, 150, 958, 197, 555, // line 20\n            504, 352, 468, 688, 10, 306, // line 21\n            987, 5, 811, 705, 462, 374, 42, // line 22\n            402, 804, 295, 406, 150, 22, 429, 268, 324, // line 23\n            270, 982, 644, 87, 505, //  line 24\n            98, 370, 19, 867, 396, 272, 760, // line 25\n            593, 793, 503, 34, 406, 456, 303, 142, 432, // line 26\n            707, 563, 837, 230, 169, 138, 420, // line 27\n            689, 503, 449, 39, 77, 404, // line 28\n            137, 624, 883, 891, 310, 404, // line 29\n            287, 961, 488, 544, 130, 531, 72, 424, 766, // line 30\n            476, 722, 780, 613, 533, 96, 553, 91, 835, 690, // line 31\n            350, 950, 359, 141, 326, 658, 832, // line 32\n            772, 127, 335, 539, 101, 959, 221, 512, // line 33\n            798, 138, 207, 999, 574, 484, 364, // line 34\n            919, 202, 971, 488, 349, 404, 448, // line 35\n            246, 211, 426, 206, 557, 27, 659, 588, 367, 961, 583, 280, // line 36\n            724, 324, 788, 685, 788, 532, 85, 139, 75, 196, // line 37\n            521, 391, 987, 810, 214, // line 38\n            679, 776, 447, 457, 25, 467, 173, 241, // line 39\n            43, 898, 412, 742, 540, 825, 259, 997, 514, // line 40\n            775, 52, 809, 871, 384, 295, 470, 114, // line 41\n            147, 69, 914, 144, 875, 278, 441, 859, 346, 281, 40, // line 42\n            89, 578, 519, 676, 473, 361, // line 43\n            78, 42, 750, 465, 218, 833, 137, 538, 962, 421, 502, 42, // line 44\n            457, 825, 26, 238, 205, 539, 109, 348, 837, 842, // line 45\n            175, 925, 399, 560, 636, // line 46\n            693, 447, 137, 679, 479, 619, 283, 458, 544, 802, 848, // line 47\n            39, 141, // line 48\n            471, 502, 663, 986, 633, 530, 598, 220, 542, 568, 219, 532, 15,  // line 49\n            840, // line 50\n            351, 993, 573, 865, 848, 239, 134, 64, 231, // line 51\n            809, 925, 43, 277, 571, // line 52\n            698, 355, 55, 847, 409, 78, 363, // line 53\n            261, 591, 695, 678, 714, 364, 804, 156, 605, // line 54\n            192, 957, 963, 447, 344, // line 55\n            524, 568, 691, 169, 218, 10, 10, 399, 46, 488, 491, 16, // line 56\n            824, 772, 265, 964, // line 57\n            345, 161, 671, 414, 726, 564, // line 58\n            155, 483, 546, 968, 591, // line 59\n            806, 120, 813, 481, 593, 667, 815, 682, 579, 298, 668, 188, // line 60\n            718, 469, 251, 52, 919, 846, 887, 637, // line 61\n            81, 51, 236, 167, 338, 963, 258, 980, 816, // line 62\n            150, 316, 389, 590, 291, 143, 284, // line 63\n            390, 559, 116, 926, 779, // line 64\n            500, 821, 594, 220, 830, 89, 915, 363, // line 65\n            623, 337, 40, 827, 828, 294, 392, // line 66\n            993, 565, 638, 307, 95, 535, 105, 632, 938, 116, 939, // line 67\n            444, 378, 283, 971, 689, 937, 736,\n            991, // line 68\n\n                 // 608, 362, 642, 262, 617, // line 140\n        ];\n\n        assert_eq!(expect_part_numbers, parts_next_to_symbols);\n        Ok(())\n    }\n```\n\nIs this insane? Yes. But I was convinced I'd got the core logic right, and there was something funky in the input I wasn't expecting. So, I went line by line of the input and compared it after each save. \n\nEventually, on line 67 of the input I found my bug and was able to build a test case around it. \n\n```rust\n    fn it_should_parse_lines_66_to_68() -> miette::Result<()> {\n        let input = \"\n        ...*...623....337.......................40..........827..............*................828....$294....392....*....*.....%..............*.....\n        .993............*....565........................638...............307.............95.......#..............535.105.........632..938.166..$939\n        .....$..444@...378...*.......4...283...971@.......*...................689..937...*.......736......@...................991..@....*...........\";\n\n        let part_numbers = input\n            .lines()\n            .enumerate()\n            .flat_map(|(i, line)| extract_part_numbers_from_line(line.trim(), i as u32))\n            .collect::<Vec<_>>();\n\n        let expected_part_numbers: Vec<u32> = vec![\n            623, 337, 40, 827, 828, 294, 392, // line 66\n            993, 565, 638, 307, 95, 535, 105, 632, 938, 166, 939, // line 67\n            444, 378, 4, 283, 971, 689, 937, 736, 991, // line 68\n        ];\n\n        assert_eq!(expected_part_numbers, part_numbers.iter().map(|p| p.number).collect::<Vec<_>>());\n\n        let symbols = input\n            .lines()\n            .enumerate()\n            .flat_map(|(i, line)| extract_symbols_from_line(line.trim(), i as u32))\n            .collect::<Vec<_>>();\n\n        let parts_next_to_symbols = part_numbers_adaject_to_a_symbol(&part_numbers, &symbols);\n\n        // There's some numbers missing from 66 and 68, that's because this is a slice so the row above doesn't trigger them\n        let expect_part_numbers = vec![\n            337, 294, // line 66\n            993, 565, 638, 307, 95, 535, 105, 632, 938, 166, 939, // line 67\n            444, 378, 971, 736 // line 68\n        ];\n\n        assert_eq!(expect_part_numbers, parts_next_to_symbols);\n        Ok(())\n    }\n```\n\nIt was a flaw in my number parsing. Line 67 is the first time a number appears at the end of the line without a non-digit following it. And my parser didn't account for that. It was annoying, but at least I was justified by the insanity that is that test.\n\nNow that it's working, I can talk about my solution. Again, I went for reliability over performance (mostly so I can feel good about my later optimisations 😉). First were some simple `struct`s and constructors:\n\n```rust\nstruct PartNumber {\n    x: u32,\n    y: u32,\n    width: u32,\n    number: u32,\n}\n\nimpl PartNumber {\n    fn new(x: u32, y: u32, width: u32, number: u32) -> Self {\n        Self {\n            x,\n            y,\n            width,\n            number,\n        }\n    }\n}\n\nstruct Symbol {\n    x: u32,\n    y: u32,\n    symbol: char,\n}\n\nimpl Symbol {\n    fn new(x: u32, y: u32, symbol: char) -> Self {\n        Self { x, y, symbol }\n    }\n\n    fn postition_equals(&self, x: u32, y: u32) -> bool {\n        self.x == x && self.y == y\n    }\n}\n```\n\nThen it was a simple case of parsing each line and extracting the part numbers and symbols.\n\n```rust\nfn extract_part_numbers_from_line(line: &str, line_index: u32) -> Vec<PartNumber> {\n    let mut part_numbers = Vec::new();\n\n    let mut in_digits = false;\n    let mut number_start = 0;\n\n    for (i, c) in line.char_indices() {\n        if c.is_ascii_digit() {\n            if !in_digits {\n                in_digits = true;\n                number_start = i;\n            }\n        } else if in_digits {\n            in_digits = false;\n            let number = line.get(number_start..i).unwrap().parse::<u32>().unwrap();\n            part_numbers.push(PartNumber::new(\n                number_start as u32,\n                line_index,\n                i as u32 - number_start as u32,\n                number,\n            ));\n        }\n    }\n\n\t// This is where my bug was, I didn't have this block so a trailing number would be lost\n    if in_digits {\n        let number = line.get(number_start..).unwrap().parse::<u32>().unwrap();\n        part_numbers.push(PartNumber::new(\n            number_start as u32,\n            line_index,\n            line.len() as u32 - number_start as u32,\n            number,\n        ));\n    }\n\n    part_numbers\n}\n\n#[tracing::instrument]\nfn extract_symbols_from_line(line: &str, line_index: u32) -> Vec<Symbol> {\n    let mut symbols = Vec::new();\n\n    for (i, c) in line.char_indices() {\n        if !c.is_ascii_digit() && c != '.' {\n            symbols.push(Symbol::new(i as u32, line_index, c));\n        }\n    }\n\n    symbols\n}\n```\n\nOk, cool, this works, now for the complex bit. Finding parts with an adjacent symbol.\n\n```rust\nimpl PartNumber {\n    fn has_adjacent_symbol(&self, symbol: &[Symbol]) -> bool {\n        let start_x = if self.x == 0 { 0 } else { self.x - 1 }; // Rust doesn't have ternary operators, you do this instead\n        let end_x = self.x + self.width + 1;\n        let start_y = if self.y == 0 { 0 } else { self.y - 1 };\n        let end_y = self.y + 1;\n\n        for x in start_x..end_x {\n            for y in start_y..=end_y {\n                if symbol.iter().any(|s| s.postition_equals(x, y)) {\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n}\n```\n\nSlightly cursed, but it works. I loop in a box around the part number and return true as soon as we see a symbol. Using this function, it's easy to find part numbers with an adjacent symbol, and then do the summation.\n\n```rust\nfn part_numbers_adaject_to_a_symbol(part_numbers: &[PartNumber], symbols: &[Symbol]) -> Vec<u32> {\n    part_numbers\n        .iter()\n        .filter(|part_number| part_number.has_adjacent_symbol(symbols))\n        .map(|part_number| part_number.number)\n        .collect::<Vec<_>>()\n}\n\npub fn process(input: &str) -> miette::Result<u32> {\n    let part_numbers = input\n        .lines()\n        .enumerate()\n        .flat_map(|(i, line)| extract_part_numbers_from_line(line.trim(), i as u32))\n        .collect::<Vec<_>>();\n\n    let symbols = input\n        .lines()\n        .enumerate()\n        .flat_map(|(i, line)| extract_symbols_from_line(line.trim(), i as u32))\n        .collect::<Vec<_>>();\n\n    let parts_next_to_symbols = part_numbers_adaject_to_a_symbol(&part_numbers, &symbols);\n\n    let sum = parts_next_to_symbols.iter().sum::<u32>();\n\n    Ok(sum)\n}\n```\n\n### Part 2\n\nPart two, funnily enough, saw us finding pairs of numbers surrounding the `*` symbol, which is very close to what I was originally doing. The changes to make this work were fairly minimal. First was making parts searchable and symbols able to search for them.\n\n```rust\nimpl PartNumber {\n    fn contains_point(&self, x: i32, y: i32) -> bool {\n        let start_x = self.x;\n        let end_x = self.x + self.width;\n\n        x >= start_x && x < end_x && y == self.y\n    }\n}\n\nimpl Symbol {\n    fn adjacent_part_numbers(&self, part_numbers: &[PartNumber]) -> Vec<i32> {\n        part_numbers\n            .iter()\n            .filter(|part_number| {\n                part_number.contains_point(self.x - 1, self.y) // left\n                    || part_number.contains_point(self.x + 1, self.y) // right\n                    || part_number.contains_point(self.x, self.y - 1) // top\n                    || part_number.contains_point(self.x, self.y + 1) // bottom\n                    || part_number.contains_point(self.x - 1, self.y - 1) // top left\n                    || part_number.contains_point(self.x + 1, self.y - 1) // top right\n                    || part_number.contains_point(self.x - 1, self.y + 1) // bottom left\n                    || part_number.contains_point(self.x + 1, self.y + 1) // bottom right\n            })\n            .map(|part_number| part_number.number)\n            .collect::<Vec<_>>()\n    }\n}\n```\n\nThere was a small change to symbol parsing, mostly to skip anything that isn't `*`.\n\n```rust\nfn extract_symbols_from_line(line: &str, line_index: i32) -> Vec<Symbol> {\n    let mut symbols = Vec::new();\n\n    for (i, c) in line.char_indices() {\n        if c == '*' {\n            symbols.push(Symbol::new(i as i32, line_index, c));\n        }\n    }\n\n    symbols\n}\n```\n\nIt was then again a case of just throwing these functions together to get them to work. This is kinda iterator-heavy, but hopefully, it's fine to follow.\n\n```rust\nfn symbols_with_2_adjacent_part_numbers(\n    symbols: &[Symbol],\n    part_numbers: &[PartNumber],\n) -> Vec<i32> {\n    symbols\n        .iter()\n        .map(|symbol| symbol.adjacent_part_numbers(part_numbers))\n        .filter(|adjacent_part_numbers| adjacent_part_numbers.len() == 2)\n        .map(|adjacent_part_numbers| adjacent_part_numbers.iter().product())\n        .collect::<Vec<_>>()\n}\n\n#[tracing::instrument]\npub fn process(input: &str) -> miette::Result<i32> {\n    let part_numbers = input\n        .lines()\n        .enumerate()\n        .flat_map(|(i, line)| extract_part_numbers_from_line(line.trim(), i as i32))\n        .collect::<Vec<_>>();\n\n    let symbols = input\n        .lines()\n        .enumerate()\n        .flat_map(|(i, line)| extract_symbols_from_line(line.trim(), i as i32))\n        .collect::<Vec<_>>();\n\n    let gear_ratios = symbols_with_2_adjacent_part_numbers(&symbols, &part_numbers);\n\n    let sum = gear_ratios.iter().sum::<i32>();\n\n    Ok(sum)\n}\n```\n\nThis felt much easier than part 1, but I think that's because I didn't spend an hour doing manual data entry to find my bug.\n\n## Optimisation\n\n### Part1\n\nAfter a break, I decided to give optimisation another go.\n\n### Part2\n\nI have chosen not to optimise part 2 as I don't see a nice way to do it. I have some guesses, but they all look quite ugly.\n\n```rust\nstruct Data {\n    symbol_map: Vec<bool>,\n    width: usize,\n}\n\nimpl Data {\n    #[tracing::instrument]\n    fn new(input: &String) -> Self {\n        let is_symbol = input\n            .lines()\n            .flat_map(|line| line.chars())\n            .map(|c| is_symbol(Some(c)))\n            .collect::<Vec<_>>();\n        let width = input.lines().next().unwrap().len();\n\n        Self { width, symbol_map }\n    }\n\n    #[tracing::instrument]\n    fn is_symbol(&self, x: i32, y: i32) -> bool {\n        if x < 0 || y < 0 {\n            return false;\n        }\n\n        match self.symbol_map.get(y as usize * self.width + x as usize) {\n            Some(v) => *v,\n            None => false,\n        }\n    }\n}\n```\n\nThis time, rather than accessing the strings as needed, I precompute whether or not a character is a symbol for the entire input. This may seem expensive, and I tried some other methods, but this came out the fastest. Doing this allows for fast lookups when processing the numbers.\n\nA small but non-insignificant change was the way I was calculating if a character is a symbol.\n\n```rust\nfn is_symbol(char: Option<char>) -> bool {\n    match char {\n        Some(c) => {\n            matches!(c, '-' | '%' | '+' | '=' | '*' | '/' | '$' | '#' | '&' | '@')\n        }\n        None => false,\n    }\n}\n```\n\nRather than checking for any symbol, it only checks the ones present in the input. And thank you to clippy for suggesting the `matches!`, it's very cool (it expands to a match statement returning true for the items listed and false for everything else).\n\nProcessing each line has become more complex. While the basic outline and operations remain unchanged, there's some extra fun.\n\n```rust\nfn parse_line(line: &str, y: i32, data: &Data) -> Vec<u32> {\n    let mut in_number = false;\n    let mut number_start = 0;\n    let mut adjacent_symbol = false;\n\n    let mut numbers = vec![];\n\n    for (i, c) in line.chars().enumerate() {\n        let i_as_i32 = i as i32;\n        if c.is_ascii_digit() {\n            if !in_number {\n                in_number = true;\n                number_start = i;\n\n                // Previous\n                if data.is_symbol(i_as_i32 - 1, y)\n                    || data.is_symbol(i_as_i32 - 1, y - 1)\n                    || data.is_symbol(i_as_i32 - 1, y + 1)\n                {\n                    adjacent_symbol = true;\n                }\n            }\n\n            // Above below\n            if (data.is_symbol(i_as_i32, y - 1)) || (data.is_symbol(i_as_i32, y + 1)) {\n                adjacent_symbol = true;\n            }\n        } else if in_number {\n            // Check self, above and below\n            if data.is_symbol(i_as_i32, y)\n                || data.is_symbol(i_as_i32, y - 1)\n                || data.is_symbol(i_as_i32, y + 1)\n            {\n                adjacent_symbol = true;\n            }\n\n            if adjacent_symbol {\n                numbers.push(line[number_start..i].parse().unwrap());\n            }\n\n            in_number = false;\n            adjacent_symbol = false;\n        }\n    }\n\n    if in_number\n        && (adjacent_symbol\n            || data.is_symbol(line.len() as i32 - 1, y - 1)\n            || data.is_symbol(line.len() as i32 - 1, y + 1))\n    {\n        numbers.push(line[number_start..].parse().unwrap());\n    }\n\n    numbers\n}\n```\n\nAfter finding the first digit like we did before, we then immediately look left and diagonally left to see if we can find a symbol.\n\n```rust\nif data.is_symbol(i_as_i32 - 1, y)\n\t|| data.is_symbol(i_as_i32 - 1, y - 1)\n\t|| data.is_symbol(i_as_i32 - 1, y + 1)\n{\n\tadjacent_symbol = true;\n}\n```\n\nThen, for every digit following we do similar, and check above and below the current character.\n\n```rust\nif (data.is_symbol(i_as_i32, y - 1)) || (data.is_symbol(i_as_i32, y + 1)) {\n\tadjacent_symbol = true;\n}\n```\n\nThen, once we've reached the end of the number, we have to check right, and diagonally right. But, we only know if we've reached the end of the number if we've seen a non-number character, so what we really need to do is check the current character, and above and below that, which has the same effect as checking right and diagonally because we're already one character to the right.\n\n```rust\nif data.is_symbol(i_as_i32, y)\n\t|| data.is_symbol(i_as_i32, y - 1)\n\t|| data.is_symbol(i_as_i32, y + 1)\n{\n\tadjacent_symbol = true;\n}\n```\n\nThe only thing to do then is not to fall prey to my earlier bug and also check if we've reached the end of the line but are still in a number. Again, here, we have to check above and below on the final character for a symbol.\n\n```rust\nif in_number\n\t&& (adjacent_symbol\n\t\t|| data.is_symbol(line.len() as i32 - 1, y - 1)\n\t\t|| data.is_symbol(line.len() as i32 - 1, y + 1))\n{\n\tnumbers.push(line[number_start..].parse().unwrap());\n}\n```\n\nCombing it all together is then a simple case of:\n\n```rust\npub fn process(input: &str) -> miette::Result<u32> {\n    let input = input\n        .lines()\n        .map(|line| line.trim())\n        .collect::<Vec<_>>()\n        .join(\"\\n\");\n\n    let data = Data::new(&input);\n\n    let sum = input\n        .lines()\n        .enumerate()\n        .flat_map(|(y, line)| parse_line(line, y as i32, &data))\n        .sum::<u32>();\n\n    Ok(sum)\n}\n```\n\nUsing these techniques has yielded a rather silly performance increase of 59x, taking us from the ~7ms area to ~120µs.\n\nOverall, I think this is a fairly intuitive optimisation. But I am very pleased with the results. I'm also glad I did it the more over-engineered way first as I would likely have had an even worse time debugging this approach to find my bug.\n\n## Additional Notes\n\nThis has been a lesson in not trusting their example input to cover all possible gotchas, I know there was one present in [day-01](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) but I managed to avoid it, and in my hubris assumed it couldn't happen to me 🤣\n\n## Results\n\n```\nday_03        fastest       │ slowest       │ median        │ mean\n├─ part1      7.107 ms      │ 15.85 ms      │ 7.342 ms      │ 7.564 ms\n├─ part1_opt  123.7 µs      │ 150.4 µs      │ 124.1 µs      │ 126.7 µs \n╰─ part2      6.111 ms      │ 6.834 ms      │ 6.355 ms      │ 6.358 ms\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-02": {
      "key": "advent-of-code-2023-day-02",
      "permalink": "/blog/advent-of-code-2023-day-02",
      "title": "Advent of Code 2023 - Day 02",
      "date": "2023-12-02T18:00:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 02. This post contains spoilers",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. See my [previous post](https://zoeaubert.me/blog/advent-of-code-2023-day-01/) to see how the project is set up.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-02) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Initial solutions\n\n### Part 1\n\nToday saw us calculating if it was possible to draw a \"hand\" of cubes out of a bag containing a set number of cubes. We were told that the bag contains `12 red cubes, 13 green cubes, and 14 blue cubes`, so drawing 10 red cubes would be valid, but 20 would not.\n\nMy initial approach is possibly a little over-engineered, but here we are. I built `structs` (objects) to store the data I needed.\n\n```rust\nstruct Bag {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\nstruct Hand {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\nstruct Game {\n    id: u32,\n    hands: Vec<Hand>, // Vec = array\n}\n```\n\nI decided it would be best to work from backwards and parse the smallest bits of data before tackling the larger stuff, so I set up a test and built a parser for each hand. The input into this parser is `1 red, 2 green, 3 blue`.\n\n```rust\nimpl Hand {\n    fn from_str(input: &str) -> Result<Self> {\n        let mut hand = Self {\n            red: 0,\n            green: 0,\n            blue: 0,\n        };\n\n        for card in input.split(',') {\n            let parts = card.trim().split(' ').collect::<Vec<_>>();\n\n            let count = parts\n                .first()\n                .ok_or_else(|| Error::CouldNotParseColorCount(card.to_string()))?;\n            let color = parts\n                .last()\n                .ok_or_else(|| Error::CouldNotParseColorCount(card.to_string()))?;\n\n            let count = count\n                .parse::<u8>()\n                .map_err(|_| Error::CouldNotParseCount(count.to_string()))?;\n\n            match *color {\n                \"red\" => hand.red = count,\n                \"green\" => hand.green = count,\n                \"blue\" => hand.blue = count,\n                _ => return Err(Error::UnknownColor(color.to_string())),\n            }\n        }\n\n        Ok(hand)\n    }\n\n    fn is_possible(&self, bag: &Bag) -> bool {\n        self.red <= bag.red && self.green <= bag.green && self.blue <= bag.blue\n    }\n}\n```\n\nI also added a function to check if the hand was valid for any given `bag`. There's a fair bit of error handling here, but it's not too messy. It splits the string on `,`, finds the number part, parses it, parses the colour component, and throws suitable errors.\n\nFor non-Rust people, `impl` allows you to add functions to a `struct`. If you're familiar with object-oriented programming, then these are similar to class methods. In Rust, we define the data structures separately from the implementation. This might seem weird, but it does have more advantages down the line.\n\nAfter getting that down, it was then just a process of adding parsers that relied upon previously built parsers.\n\n```rust\nimpl Game {\n    fn from_str(input: &str) -> Result<Self> {\n        let id_and_hands = input.split(':').collect::<Vec<_>>();\n\n        let id = id_and_hands\n            .first()\n            .ok_or_else(|| Error::CouldNotParseGameId(input.to_string()))?\n            .trim()\n            .split(' ')\n            .nth(1)\n            .ok_or_else(|| Error::CouldNotParseGameId(input.to_string()))?\n            .parse::<u32>()\n            .map_err(|_| Error::CouldNotParseGameId(input.to_string()))?;\n\n        let hands = id_and_hands\n            .last()\n            .ok_or_else(|| Error::CouldNotParseGameHands(input.to_string()))?;\n\n        let hands = hands\n            .split(';')\n            .map(Hand::from_str)\n            .collect::<Result<Vec<_>>>()?;\n\n        Ok(Self { id, hands })\n    }\n\n    fn is_possible(&self, bag: &Bag) -> bool {\n        self.hands.iter().all(|hand| hand.is_possible(bag))\n    }\n}\n\npub fn process(input: &str) -> miette::Result<u32> { // Main function\n    let bag = Bag {\n        red: 12,\n        green: 13,\n        blue: 14,\n    };\n\n    let games = input\n        .lines()\n        .map(Game::from_str)\n        .collect::<Result<Vec<_>>>()?;\n\n    let possible_games = games\n        .iter()\n        .filter(|game| game.is_possible(&bag))\n        .map(|game| game.id)\n        .sum();\n\n    Ok(possible_games)\n}\n```\n\nI am leaning quite heavily into iterators here, but hopefully, if you're familiar with using them in other languages or lambda-like functions, these won't seem too weird.  `ok_or_else` transforms an `Option` (a different way of handling `null`) into an error if it's `None/null`.\n\nOverall, this wasn't too complex, and I feel the code is pretty clean.\n\n### Part 2\n\nPart 2 was possibly easier than Part 1. It was very simple to change the logic from \"is hand possible\" to \"work out the max hand\". The only real change was to `Game`.\n\n```rust\nimpl Game {\n    fn min_possible_bag(&self) -> Bag {\n        let mut bag = Bag {\n            red: 0,\n            green: 0,\n            blue: 0,\n        };\n\n        for hand in &self.hands {\n            bag.red = bag.red.max(hand.red);\n            bag.green = bag.green.max(hand.green);\n            bag.blue = bag.blue.max(hand.blue);\n        }\n\n        bag\n    }\n\n    #[tracing::instrument]\n    fn power_set(&self) -> u32 {\n        let bag = self.min_possible_bag();\n\n        bag.red as u32 * bag.green as u32 * bag.blue as u32\n    }\n}\n```\n\nWith this, it was easy to change the `process` function to respect it.\n\n```rust\npub fn process(input: &str) -> miette::Result<u32> {\n    let games = input\n        .lines()\n        .map(Game::from_str)\n        .collect::<Result<Vec<_>>>()?;\n\n    let power_sets = games\n        .iter()\n        .map(|game| game.power_set())\n        .collect::<Vec<_>>();\n\n    Ok(power_sets.iter().sum())\n}\n```\n\n## Optimisation\n\nI had a lot of fun with this.\n\n### Part 1\n\n#### Optimisation Pass 1\n\nWhile building the initial solution, I spotted a number of areas that could be improved. Mostly parsing more data than necessary. My initial solution parsed everything, and only once it's built a complete picture did it determine the number of possible games. But we know if a game is impossible much more quickly than that. If, at any point, while parsing a hand colour value, we spot a value that is higher than the possible number, we know that nothing else in that game matters as we've broken a rule, so we can exit at that point and declare the game impossible. The first step was parsing the hands:\n\n```rust\nfn parse_hand_color(input: &str, bag: &Bag) -> Result<bool> {\n    let count_chars = input\n        .chars()\n        .take_while(|c| c.is_ascii_digit())\n        .collect::<String>();\n\n    let color_start = count_chars.len() + 1;\n\n    let count = count_chars\n        .parse::<u8>()\n        .map_err(|_| Error::CouldNotParseCount(input.to_string()))?;\n\n    if count > bag.red || count > bag.green || count > bag.blue {\n        return Ok(false);\n    }\n\n    let color = input\n        .get(color_start..color_start + 1)\n        .ok_or_else(|| Error::CouldNotParseColorCount(input.to_string()))?;\n\n    match color {\n        \"r\" => {\n            if count > bag.red {\n                return Ok(false);\n            }\n        }\n        \"g\" => {\n            if count > bag.green {\n                return Ok(false);\n            }\n        }\n        \"b\" => {\n            if count > bag.blue {\n                return Ok(false);\n            }\n        }\n        _ => return Err(Error::UnknownColor(color.to_string())),\n    }\n\n    Ok(true)\n}\n\nfn parse_hand(input: &str, bag: &Bag) -> Result<bool> {\n    for card in input.split(',') {\n        if !parse_hand_color(card.trim(), bag)? {\n            return Ok(false);\n        }\n    }\n\n    Ok(true)\n}\n```\n\nThe actual parsing here looks similar to the first parser. Notable differences include not splitting the string but instead using what we know about the structure of the input to be able to jump ahead (this will be important later). And, rather than relying on iterators, moving back to traditional loops and exiting as early as possible. \n\nWe also don't return a `Hand` struct anymore, but instead, just return if the hand is possible or not. One additional trick I pulled was rather than checking the whole colour name, I only check the first letter as we know there are no collisions between the colour's first characters.\n\nThe `Game` and input processing have changed in a similar way. \n\n```rust\nenum GameResult {\n    Possible { game_id: u32 },\n    Impossible,\n}\n\nfn parse_game(input: &str, bag: &Bag) -> Result<GameResult> {\n    let id_chars: String = input\n        .chars()\n        .skip(5)\n        .take_while(|c| c.is_ascii_digit())\n        .collect();\n\n    let hands_start = 5 + id_chars.len() + 2;\n\n    let game_id = id_chars\n        .parse::<u32>()\n        .map_err(|_| Error::CouldNotParseGameId(id_chars))?;\n\n    let hands_text = input[hands_start..].trim();\n\n    for hand in hands_text.split(';') {\n        if !parse_hand(hand, bag)? {\n            return Ok(GameResult::Impossible);\n        }\n    }\n\n    Ok(GameResult::Possible { game_id })\n}\n\npub fn process(input: &str) -> miette::Result<u32> {\n    let bag = Bag {\n        red: 12,\n        green: 13,\n        blue: 14,\n    };\n\n    let mut possible_game_ids = vec![];\n\n    for line in input.lines() {\n        let game_result = parse_game(line.trim(), &bag)?;\n        match game_result {\n            GameResult::Possible { game_id } => {\n                possible_game_ids.push(game_id);\n            }\n            GameResult::Impossible => {}\n        }\n    }\n\n    Ok(possible_game_ids.iter().sum())\n}\n```\n\nI also introduced `GameResult` to pass the minimum amount of data required back to the caller to be able to determine if the game was possible and what ID it had. I dislike tuples so chose not to use them.\n\nThese optimisations resulted in a ~2.6x performance increase, but we can go further.\n\n#### Optimisation Pass 2\n\nBuilding on what I touched on before, there's a lot of performance to be gained by our knowledge of the structure of the input.\n\n```\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\n```\n\nWe know that the first 5 characters are skippable. We know that after the end of the game ID, there are two characters of dead space, and then we start parsing hands. We then know that after the number of cubes for each colour, there's a space, a colour and then a `,` or a `;`. Turns out we don't care about whether it's a `,` or a `;` as there are no repeated values per hand. So all we actually need to check is each number colour pairing, and we can forget the concept of hands. Additionally, building on the previous, we only need to check the first letter of colour and we automatically know the length of the string and can skip to the next hand without having to parse more data. \n\nBefore I show you the code, this is not what I'd call best practices, while there's nothing `unsafe`, there is potential for index out-of-bounds errors to occur.\n\n```rust\nenum HandResult {\n    Possible { length: usize },\n    Impossible,\n}\n\nfn parse_hand_color(input: &str, bag: &Bag) -> Result<HandResult> {\n    let mut count_chars: String = String::new();\n\n    for c in input[0..5].chars() {\n        if c.is_ascii_digit() {\n            count_chars.push(c);\n        } else {\n            break;\n        }\n    }\n    let color_start = count_chars.len() + 1;\n\n    let count = count_chars\n        .parse::<u8>()\n        .map_err(|_| Error::CouldNotParseCount(input.to_string()))?;\n\n    let color = input\n        .get(color_start..color_start + 1)\n        .ok_or_else(|| Error::CouldNotParseColorCount(input.to_string()))?;\n\n    match color {\n        \"r\" => {\n            if count > bag.red {\n                return Ok(HandResult::Impossible);\n            } else {\n                return Ok(HandResult::Possible {\n                    length: color_start + 3,\n                });\n            }\n        }\n        \"g\" => {\n            if count > bag.green {\n                return Ok(HandResult::Impossible);\n            } else {\n                return Ok(HandResult::Possible {\n                    length: color_start + 5,\n                });\n            }\n        }\n        \"b\" => {\n            if count > bag.blue {\n                return Ok(HandResult::Impossible);\n            } else {\n                return Ok(HandResult::Possible {\n                    length: color_start + 4,\n                });\n            }\n        }\n        _ => return Err(Error::UnknownColor(color.to_string())),\n    }\n}\n```\n\nFirstly we've gone from using an iterator to a string building for-loop to get the number of cubes in a hand. Previously we were checking for digits on all characters, but we don't need to as we know as soon as we've seen a non-digit character we can stop checking. From there the code is fairly similar to the previous implementation, but this time if it is a possible hand we also return the length of consumed input to allow us to skip to the next hand.\n\n```rust\nfn parse_game(input: &str, bag: &Bag) -> Result<GameResult> {\n    let mut id_chars: String = String::new();\n\n    for c in input[5..10].chars() {\n        if c.is_ascii_digit() {\n            id_chars.push(c);\n        } else {\n            break;\n        }\n    }\n\n    let hands_start = 5 + id_chars.len() + 2;\n\n    let game_id = id_chars\n        .parse::<u32>()\n        .map_err(|_| Error::CouldNotParseGameId(id_chars))?;\n\n    let mut index = hands_start;\n\n    while index < input.len() {\n        let hand = &input[index..];\n\n        let hand_result = parse_hand_color(hand, bag)?;\n\n        match hand_result {\n            HandResult::Possible { length } => {\n                index += length + 2;\n            }\n            HandResult::Impossible { .. } => {\n                return Ok(GameResult::Impossible);\n            }\n        }\n    }\n\n    Ok(GameResult::Possible { game_id })\n}\n```\n\nUsing a similar technique to get the game ID, we then use the new hand parser to skip through the list of hands using its returned length. The `process` function remains unchanged.\n\nThis final approach has a ~4.2x performance gain over the initial solution and a ~1.6x over the previously optimised solution. Is the new unreadability worth it? Probably not, but it sure is fun.\n\n### Part 2\n\nWhile there we some changes required to optimise part 2, it's similar to part 1. The `parse_hand_color` function now returns a hand and colour rather than a validity check.\n\n```rust\nenum Hand {\n    Red { consumed: u8, count: u8 },\n    Green { consumed: u8, count: u8 },\n    Blue { consumed: u8, count: u8 },\n}\n\nfn parse_hand_color(input: &str) -> Result<Hand> {\n    let mut count_chars: String = String::new();\n\n    for c in input[0..5].chars() {\n        if c.is_ascii_digit() {\n            count_chars.push(c);\n        } else {\n            break;\n        }\n    }\n    let color_start = count_chars.len() + 1;\n\n    let count = count_chars\n        .parse::<u8>()\n        .map_err(|_| Error::CouldNotParseCount(input.to_string()))?;\n\n    let color = input\n        .get(color_start..color_start + 1)\n        .ok_or_else(|| Error::CouldNotParseColorCount(input.to_string()))?;\n\n    match color {\n        \"r\" => Ok(Hand::Red {\n            consumed: color_start as u8 + 3,\n            count,\n        }),\n        \"g\" => Ok(Hand::Green {\n            consumed: color_start as u8 + 5,\n            count,\n        }),\n        \"b\" => Ok(Hand::Blue {\n            consumed: color_start as u8 + 4,\n            count,\n        }),\n        _ => return Err(Error::UnknownColor(color.to_string())),\n    }\n}\n```\n\nSimialrly, `parse_game` saw some changes but still very similar to the part 1 optimistion.\n\n```rust\nfn parse_game(input: &str) -> Result<u32> {\n    let input = input.trim();\n        \n    let mut hands_start = 0;\n\n    for c in input[0..10].chars() {\n        if c.eq(&':') {\n            break;\n        } else {\n            hands_start += 1;\n        }\n    }\n\n    hands_start += 1;\n\n    let mut index = hands_start;\n\n    let mut max_red: u32 = 0;\n    let mut max_green: u32 = 0;\n    let mut max_blue: u32 = 0;\n\n    while index < input.len() {\n        let hand = &input[index..];\n\n        let hand_result = parse_hand_color(hand.trim())?;\n\n        match hand_result {\n            Hand::Red { consumed, count } => {\n                max_red = max_red.max(count as u32);\n                index += consumed as usize;\n            }\n            Hand::Green { consumed, count } => {\n                max_green = max_green.max(count as u32);\n                index += consumed as usize;\n            }\n            Hand::Blue { consumed, count } => {\n                max_blue = max_blue.max(count as u32);\n                index += consumed as usize;\n            }\n        }\n\n        index += 2;\n    }\n\n    Ok(max_red * max_green * max_blue)\n}\n\npub fn process(input: &str) -> miette::Result<u32> {\n    let power_sets = input.lines().map(parse_game).collect::<Result<Vec<_>>>()?;\n\n    Ok(power_sets.iter().sum())\n}\n```\n\nThis approach yielded a ~2.8x performance increase.\n\n## Additional Notes\n\nI did try going further with the optimisation for part 1, but no changes I made improved upon my second attempt. This included some rather unpleasant un-check array reading and unsafe code, but it was still ultimately slower, which surprised me. And again, multi-threading did not help here as the input data was tiny.\n\n## Results\n\n```\nday_02         fastest       │ slowest       │ median        │ mean\n├─ part1       77.79 µs      │ 197 µs        │ 159.3 µs      │ 142.4 µs\n├─ part1_opt   53.41 µs      │ 82.79 µs      │ 60.08 µs      │ 61.02 µs\n├─ part1_opt2  36.66 µs      │ 43.2 µs       │ 37.08 µs      │ 37.45 µs\n├─ part2       104.3 µs      │ 144.4 µs      │ 112.8 µs      │ 116.2 µs \n╰─ part2_opt   49.2 µs       │ 58.99 µs      │ 49.49 µs      │ 49.96 µs\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "advent-of-code-2023-day-01": {
      "key": "advent-of-code-2023-day-01",
      "permalink": "/blog/advent-of-code-2023-day-01",
      "title": "Advent of Code 2023 - Day 01",
      "date": "2023-12-01T13:00:00.000Z",
      "description": "A discussion of my solution to Advent of Code 2023 - Day 01. This post contains spoilers",
      "content": "[Advent of Code](https://adventofcode.com/) is a yearly programming challenge. I've followed other people doing it before and thought I'd take a crack at it this year. Let's see how far I get. It goes without saying that this post will contain spoilers.\n\nTo view my [solutions](https://github.com/GeekyAubergine/advent-of-code/tree/main/2023/day-01) in full, check them out on GitHub. See my [previous posts](https://zoeaubert.me/tags/advent-of-code/) for other solutions.\n\n## Setup and structure\n\nUnsurprisingly I'm going to use [Rust](https://www.rust-lang.org/) for this. I had an idea about how I wanted to structure the project but then [Chris Biscardi](https://www.youtube.com/@chrisbiscardi) posted a great [video](https://www.youtube.com/watch?v=fEQv-cqzbPg) outlining their project structure. I've ~~borrowed~~ _yoinked_ their approach and made some small modifications. It's a little confusing at first but if you've used Rust before it's probably fine. The video explains it well.\n\nYou'll notice I have `part1.rs` and `part1_opt.rs`. I thought it would be to separately store my first pass approach, and a more optimised approach and compare the two. It helps that I have a benchmarking tool that allows me to directly compare my solutions. The [benchmarks](https://github.com/GeekyAubergine/advent-of-code/blob/main/2023/benchmarks/all.txt) are stored here.\n\n## Initial solutions\n\n### Part 1\n\nThis was a nice easy start. Given a set of strings, extract the first and last digit from each string, and join them to make a 2 digit number, then sum all the digits. For example, `m9qvkqlgfhtwo3seven4seven` becomes 94.\n\nTo get the digits I first extracted the digits from the string:\n\n```rust\nfn extract_digits(input: &str) -> Vec<u64> {\n    input\n        .chars()\n        .filter_map(|c| c.to_digit(10))\n        .map(|d| d as u64)\n        .collect()\n}\n```\n\nThis is pleasantly easy in Rust. I then took the digits, got the first and last, and build a new string to then parse:\n\n```rust\nfn number_for_line(line: &str) -> Result<u64> {\n    let digits = extract_digits(line);\n    let first = digits.first().ok_or_else(|| Error::NoFirstDigitInLine)?;\n    let last = digits.last().ok_or_else(|| Error::NoLastDigitInLine)?;\n    let string = format!(\"{}{}\", first, last);\n    Ok(string.parse::<u64>()?)\n}\n```\n\n(If you're new to Rust you can ignore the `ok_or_else` part, it's just error handling and does not change the way it works). \n\nFrom there it again, very simple to sum up the value from each line:\n\n```rust\npub fn process(input: &str) -> miette::Result<u64> {\n    Ok(input\n        .lines()\n        .map(number_for_line)\n        .collect::<Result<Vec<u64>>>()\n        .map(|v| v.iter().sum())?)\n}\n```\n\n### Part 2\n\nNow we get the fun twist. Rather than just parsing digits, we also need to parse the numbers as words. For example `eight33` becomes `83`.\n\nI took a potentially cursed approach to this but I didn't think RegEx was the right tool for the job, so instead I did this:\n\n```rust\nfn parse_digit(input: &str) -> Result<u64> {\n    let first_char = input\n        .chars()\n        .next()\n        .ok_or_else(|| Error::NoFirstDigitInLine)?;\n\n    if let Some(digit) = first_char.to_digit(10) {\n        return Ok(digit as u64);\n    }\n\n    if input.starts_with(\"zero\") {\n        return Ok(0);\n    }\n\n    if input.starts_with(\"one\") {\n        return Ok(1);\n    }\n\n    if input.starts_with(\"two\") {\n        return Ok(2);\n    }\n\n    if input.starts_with(\"three\") {\n        return Ok(3);\n    }\n\n    if input.starts_with(\"four\") {\n        return Ok(4);\n    }\n\n    if input.starts_with(\"five\") {\n        return Ok(5);\n    }\n\n    if input.starts_with(\"six\") {\n        return Ok(6);\n    }\n\n    if input.starts_with(\"seven\") {\n        return Ok(7);\n    }\n\n    if input.starts_with(\"eight\") {\n        return Ok(8);\n    }\n\n    if input.starts_with(\"nine\") {\n        return Ok(9);\n    }\n\n    Err(Error::ParseBasicIntError())\n}\n```\n\nCursed, I know, but it worked and that's kind of what I'm striving for. Wanting to do everything perfectly all the time is a massive problem when it comes to me actually finishing projects. I then use this new parser in a new `extract_digits` function:\n\n```rust\nfn extract_digits(input: &str) -> Result<Vec<u64>> {\n    let mut digits = Vec::new();\n    for i in 0..input.len() {\n        match parse_digit(&input[i..]) {\n            Ok(d) => digits.push(d),\n            Err(_) => continue,\n        }\n    }\n\n    Ok(digits)\n}\n```\n\nFrom there everything is the same as part 1.\n\n## Optimisation\n\nNow on to the fun stuff, let's make this go further.\n\n### Part 1\n\nThe first step was no to try and parse the whole string for all digits, this is wasteful. Instead I built two new functions that move inwards from either end of the string and return as soon as they've found a digit.\n\n```rust\nfn extract_first_digit(input: &str) -> Result<u8> {\n    for c in input.chars() {\n        if let Some(digit) = c.to_digit(10) {\n            return Ok(digit as u8);\n        }\n    }\n\n    Err(Error::NoFirstDigitInLine)\n}\n\nfn extract_last_digit(input: &str) -> Result<u8> {\n    for c in input.chars().rev() {\n        if let Some(digit) = c.to_digit(10) {\n            return Ok(digit as u8);\n        }\n    }\n\n    Err(Error::NoLastDigitInLine)\n}\n```\n\nThe next tiny improvement was to also not build a new string to parse, but instead, use \"maths\" . This now leaves the `number_for_line` function as:\n\n```rust\nfn number_for_line(line: &str) -> Result<u32> {\n    let first = extract_first_digit(line)?;\n    let last = extract_last_digit(line)?;\n    Ok((first * 10 + last) as u32)\n}\n```\n\nWith everything else remaining the same I got a ~2.4 time performance increase. For the full results scroll to the bottom of this post.\n\n### Part 2\n\nAfter applying the same optimisations as I did in part 1 I got stuck. There was little I could see to make it better. I did try some replacement things, but there are some well thought out gotchas that tripped me up. For example `eightwothree`, depending on the order of your replacements, `two` will get replaced first leaving `eigh2three`, of which `2` is now the first digit, which is wrong. \n\nInterestingly this resulted in a ~3x performance gain vs part 1. I suspect this is because the parsing is more expensive so doing less of it is just better (who'd've guessed 🤣).\n\n### Additional Notes\n\nI also tried multithreading, and as I suspected, on a problem this small the overhead is too high to make it worth it, single-threaded is the way to go.\n\nI never properly explored the RegEx solution, maybe it was better, but I would be surprised as I suspect you'd have to do the `starts_with` or `===` either way. However it wouldn't likely suffer from my issue where the string might be smaller than 5 characters and needs to be padded to prevent an index out-of-bounds error.\n\n## Results\n\n```\nday_01        fastest       │ slowest       │ median        │ mean\n├─ part1      104.9 µs      │ 126.7 µs      │ 106.2 µs      │ 108.8 µs\n├─ part1_opt  43.83 µs      │ 60.29 µs      │ 44.08 µs      │ 45.45 µs\n├─ part2      214.2 µs      │ 246.9 µs      │ 217.1 µs      │ 220 µs\n╰─ part2_opt  71.24 µs      │ 97.7 µs       │ 71.83 µs      │ 74.24 µs\n```",
      "tags": [
        "Programming",
        "AdventOfCode",
        "Rust"
      ],
      "hero": null,
      "images": []
    },
    "hackathon-accelos": {
      "key": "hackathon-accelos",
      "permalink": "/blog/hackathon-accelos",
      "title": "Hackathon - AccelOS",
      "date": "2023-11-19T23:30:00.000Z",
      "description": "I attended a hackathon with the theme Silly Interfaces and created a balance-based input for a simple operating system.",
      "content": "![Screen shot of a basic operating system interface listing Main, Files and Email on the left and side. On the right hand side a maze with various coloured circles and walls](https://cdn.geekyaubergine.com/2023/11/19/2023-11-19T22.55.24.png)\n\nYesterday, I attended a hackathon with the theme \"Silly Interfaces\". \n\nTLDR: I created a game where you had to balance a blob through a maze, changing its colour to match the colour of the option you want to select from an Operating System (OS) menu. The game is played on the browser, but the balance controls are controlled by tilting your phone using a companion app (not included). \n\nYou can [play the game](https://accelos.zoeaubert.me/) and [read the code](https://github.com/GeekyAubergine/accelo-os). To make it playable without a mobile device, I have changed the balance input to a keyboard input using WASD. To change the blob's colour, go over one of the coloured circles (you can go over multiple to combine colours to make the other colours). To select an option, you must go over the coloured square of the option you want, and your blob must be that colour.\n\nWhy's it called AccelOO? Because Accelerometer OS. And yes, I realise now, after calling it that, that actually I'm using the gyroscope, not the accelerometer, but here we are 🤷‍♀️.\n\n## The Idea\n\nAfter a short discussion with others about what constituted \"silly\", I was left with an initial choice. Did I want to go with \"silly\" as in annoying or \"silly\" as in comical? I was heading down the comical route until I overheard another conversation about using facial expressions to control an OS. They quickly dismissed the idea, but I liked it, though I didn't want to do anything with machine learning. So, I was left with the challenge of coming up with a silly way to control an OS.\n\nA long time ago, I spent a silly number of hours playing [Mercury Meltdown](https://en.wikipedia.org/wiki/Mercury_Meltdown) on the [PSP](https://en.wikipedia.org/wiki/PlayStation_Portable). In it, you have to move blobs of mercury around a tiltable map and change the colour of the blobs to match the goal colours. I loved this game and how complex the controls were (I've often thought about remaking it). I decided this was probably a good input system. You move and change the colour of a blob around to make it the colour of the option you want to select. I was initially going to include some of the more complex mechanics of Mercury Meltdown, such as splitting and merging blobs, but that proved too complex.\n\nTo top this off, rather than just your keyboard, imagine if you had to balance the map using your phone. Not only was this annoying because it's very hard to hold it perfectly level, but because the game is on one screen and your phone is in your hand. There's a weird disconnect and mental lag compared to it all being on your phone, which adds to the fun.\n\n## The Build\n\nI turned to familiar tools for this. Similar to my [previous hackathon](https://zoeaubert.me/blog/hack-pompey-2023/), I decided to use TypeScript (TS) with the canvas and [Vite](https://vitejs.dev/). Borrowing some [code](https://github.com/GeekyAubergine/blahbarian/tree/hackathon) and styles from that project, I was quickly up and running.\n\nThe first step was to get the core game functionality going. I decided on a much less complex system for rendering than previously, which helped a lot, though it has some rough edges. I wouldn't do this in a team, but it was just fine for solo. After getting the map and blobs rendering, it was time to work on the physics. This was pretty straightforward, to the point that there are bugs; for example, the blob does a simple collision check on the top, bottom, left and right of it before moving and stops moving in that direction. You can slightly clip inside if you approach a wall at an angle. It's annoying but not problematic enough to spend too much time on it.\n\nFrom there, setting up the blob colour mechanics and goal detection wasn't too much hassle. I initially made the colour system very flexible, but after some complications, I decided to make it a small enum of just the colours you see. Adding more is very manual, so I didn't go any further.\n\nFlushed with confidence, I decided to build the map. This took a surprisingly long time. In my infinite wisdom, I built the map manually in code rather than parsing a map file. It might've been quicker in retrospect to build the parser, but by the time I came to that conclusion, it was too late. \n\nThis then leads me to what is a significant part of the project. The phone balancing system.\n\n### Mobile Shenanigans\n\nI remember learning some time ago that the browser had access to the [gyroscope](https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope), and I was right, except I very much wasn't.\n\nThe problems first started when for some reason, no mobile device could access the site. It ran fine on people's laptops, but no mobile device could resolve the host. I wrote this off to some oddity with the network at the venue or something else. I was thankfully able to connect to it from my phone if I was on a mobile hotspot though, so I used that. \n\nThinking that was the end of my problems, I charged on and added the code to access the gyroscope. Enter roadblock 2. Chrome does not actually support the gyroscope, and neither does Safari (or mobile). I then checked the [caniuse](https://caniuse.com/gyroscope) for it and, with relief, noticed that Android browsers seemed to support it. So, I borrowed an Android device. Unsurprisingly, despite it being up to date, it didn't work either.\n\nNow entering a mild panic, I turned to the only tool I knew _might_ work, [ReactNative](https://reactnative.dev/). I quickly built what is probably my most janky project to date. The code for it is not Github as it is not worthy of it, and I don't want people thinking it's good. But you can enjoy it here.\n\n```ts\nimport React, {useEffect} from 'react';\nimport {\n  Button,\n  SafeAreaView,\n  StatusBar,\n  Text,\n  useColorScheme,\n} from 'react-native';\n\nimport {\n  gyroscope,\n  setUpdateIntervalForType,\n  SensorTypes,\n} from 'react-native-sensors';\nimport {Colors} from 'react-native/Libraries/NewAppScreen';\n\nlet gyro = {x: 0, y: 0, z: 0};\n\nfunction App(): JSX.Element {\n  const isDarkMode = useColorScheme() === 'dark';\n\n  useEffect(() => {\n    const ws = new WebSocket('ws://172.20.10.3:3000');\n    console.log('connecting');\n    ws.onopen = () => {\n      console.log('connected');\n\n      setInterval(() => {\n        ws.send(\n          JSON.stringify({\n            type: 'gyro',\n            ...gyro,\n          }),\n        );\n        // console.log('sent');\n      }, 100);\n    };\n  }, []);\n\n  const backgroundStyle = {\n    backgroundColor: isDarkMode ? Colors.darker : Colors.lighter,\n  };\n\n  setUpdateIntervalForType(SensorTypes.gyroscope, 20); // defaults to 100ms\n\n  gyroscope.subscribe(({x, y, z}) => {\n    gyro = {\n      x: x + gyro.x,\n      y: y + gyro.y,\n      z: z + gyro.z,\n    };\n  });\n\n  return (\n    <SafeAreaView style={backgroundStyle}>\n      <StatusBar\n        barStyle={isDarkMode ? 'light-content' : 'dark-content'}\n        backgroundColor={backgroundStyle.backgroundColor}\n      />\n      <Text>Gyroscope:</Text>\n      <Button\n        onPress={() => {\n          gyro = {x: 0, y: 0, z: 0};\n        }}\n        title=\"Reset\"\n      />\n    </SafeAreaView>\n  );\n}\n\nexport default App;\n\n```\n\nThis took a while to get working, but thank your deity of choice, it did. \n\nOne problem I almost encountered was Apple's developer licensing. If I hadn't had access to the Android device, I wouldn't have been able to test it on any device, as I was not paying for the license to build it on my phone. \n\nThankfully, this worked as intended, and after some playing around, I integrated it with the website. One fun thing I didn't notice in the documentation is that this library only sends delta updates, so you have to track the communicative value to get the actual tilt of the device.\n\n### The OS Part\n\nAt this point, I was running out of steam. I opted for a very quick and dirty implementation of the \"OS\". It's a series of states with a list of options. The game part dispatches a \"player triggered goal with colour X\" event, and the OS part determines if it's a valid option and transitions to the next suitable state. It's very basic, but is enough to demonstrate the silly part which is the control scheme.\n\n## Conclusion\n\nThis was a lot of fun. I don't consider myself much of a \"creative ideas\" person and usually rely on others in the team to come up with ideas and implement them. But as I was solo this time, so I couldn't do that, and I was very pleased with what I came up with, even if part of the idea was \"borrowed\".\n\nThere wouldn't be much I'd do differently other than not do something that interacts with the core components of a mobile device unless the whole project is on mobile. And if it is, it would be the first thing I'd check to see if it worked. While the project is doable with keyboard input, it lacks a lot of charm that the balancing aspect introduces. Without it, I'd've felt bad about presenting it. So, leaving it so late to test it was silly.\n\nOverall, I consider this a successful project.",
      "tags": [
        "Programming",
        "GameDev",
        "Hackathon"
      ],
      "hero": {
        "src": "https://cdn.geekyaubergine.com/2023/11/19/2023-11-19T22.55.24.png",
        "alt": "Screen shot of a basic operating system interface listing Main, Files and Email on the left and side. On the right hand side a maze with various coloured circles and walls",
        "date": "2023-11-19T23:30:00.000Z",
        "parentPermalink": "/blog/hackathon-accelos",
        "width": 980,
        "height": 449,
        "orientation": "landscape",
        "title": null
      },
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2023/11/19/2023-11-19T22.55.24.png",
          "alt": "Screen shot of a basic operating system interface listing Main, Files and Email on the left and side. On the right hand side a maze with various coloured circles and walls",
          "date": "2023-11-19T23:30:00.000Z",
          "parentPermalink": "/blog/hackathon-accelos",
          "width": 980,
          "height": 449,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "leveraging-your-type-system": {
      "key": "leveraging-your-type-system",
      "permalink": "/blog/leveraging-your-type-system",
      "title": "Leveraging Your Type System",
      "date": "2023-06-23T17:00:00.000Z",
      "description": "When programming it is easy to find yourself in unexpected or invalid states. Using your compiler and type system, you can make these invalid states irrepresentable and prevent you from entering them and stopping bugs at the compiler rather than detecting them in production.",
      "content": "Early last year, I decided to give Rust a go, and as many people can attest, I won't shut up about it. Fear not; this is not a post about Rust. One of the many features Rust provides is an excellent type system which results in a high level of safety. Since then, I have tried to replicate the level of safety in other languages.\n\n## Making Invalid States Unrepresentable\n\nDuring my experiments with Rust, I came across [NoBoilerplate](https://www.youtube.com/@NoBoilerplate)'s excellent Rust videos. In many of the videos, they discuss the concept of \"Making Invalid States Unrepresentable\". This concept is relatively widespread, and after playing around with it, I think I finally have my own interpretation of it:\n\n> If you represent all possible states, which includes all error states, you make it impossible to enter an unexpected [invalid] state\n\nI've also taken \"state\" to mean the state of anything from your entire application to a single object/class/struct.\n\nThe power of this approach is that if you use it correctly. You can get the compiler/static analyser (compiler from here on) to do a lot of work for you and prevent you from making mistakes.\n\nI'll be using TypeScript, but this should apply to almost any language. [View example code](https://github.com/GeekyAubergine/leveraging-your-type-system-examples).\n\n## Invoice Example\n\n```ts\ntype BadInvoice = {\n    uuid: string;\n    amount: number;\n    state: 'pending' | 'paid' | 'cancelled'\n    createdAt: string;\n    paidAt: string | null;\n    paymentMethod: string | null;\n    cancelledAt: string | null;\n    cancelledReason: string | null;\n}\n\nconst validState: BadInvoice = {\n    uuid: '123',\n    amount: 100,\n    state: 'paid',\n    createdAt: '2020-01-01',\n    paidAt: '2020-01-03',\n    paymentMethod: null,\n    cancelledAt: null,\n    cancelledReason: null,\n}\n\nconst invalidState: BadInvoice = {\n    uuid: '123',\n    amount: 100,\n    state: 'pending',\n    createdAt: '2020-01-01',\n    paidAt: '2020-01-03',\n    paymentMethod: null,\n    cancelledAt: null,\n    cancelledReason: null,\n}\n```\n\nIn this example, we're considering an Invoice to be our state. I've included both a valid and invalid state, and the difference is subtle. How would you protect against this happening? If adding a `payInvoice` function, I probably would've written something like this:\n\n```ts\nfunction payBadInvoice(invoice: BadInvoice, payment_method: string): BadInvoice {\n    if (invoice.state !== 'pending') {\n        throw new Error('Invoice is not pending');\n    }\n\n    if (invoice.cancelledAt !== null || invoice.cancelledReason !== null) {\n        throw new Error('Invoice is canceled');\n    }\n\n    if (invoice.paidAt !== null || invoice.paymentMethod !== null) {\n        throw new Error('Invoice is already paid');\n    }\n\n    const newInvoice: BadInvoice = {\n        ...invoice,\n        state: 'paid',\n        paymentMethod: payment_method,\n    }\n\n    return newInvoice;\n}\n```\n\nThere are several things wrong with this approach:\n\n1. We've checked that we are in a `pending` state\n2. We can't trust the data actually matches the expected state for a `pending` invoice, so we have to check that it's not mistakenly a `paid` or `cancelled`\n3. We return a new updated invoice with no more guarantees than the invoice that we were given\n\nIssues 2 & 3 are particularly problematic as it is prone to errors. For example, if you check `paidAt` but forget to check `paymentMethod`, you might end up in a position where you incorrectly overwrite the `paymentMethod` when you should've defended against it. \n\nSo how can we improve upon this? We need to represent each state an Invoice can be in and what data each state needs to be valid.\n\n```ts\ntype GoodInvoicePending = {\n  uuid: string;\n  amount: number;\n  state: \"pending\";\n  createdAt: string;\n};\n\ntype GoodInvoicePaid = {\n  uuid: string;\n  amount: number;\n  state: \"paid\";\n  createdAt: string;\n  paidAt: string;\n  paymentMethod: string;\n};\n\ntype GoodInvoiceCancelled = {\n  uuid: string;\n  amount: number;\n  state: \"cancelled\";\n  createdAt: string;\n  cancelledAt: string;\n  cancelledReason: string;\n};\n```\n\nWe now have a representation/type for each valid state of an Invoice. We have made it impossible for a pending invoice to have `cancelledAt` set on it, or to have a paid invoice with a no `paymentMethod`. So how can we use this to our advantage?\n\n```ts\nfunction payGoodInvoiceGeneric(\n  invoice: GoodInvoice,\n  paymentMethod: string\n): GoodInvoice {\n  if (invoice.state !== \"pending\") {\n    throw new Error(\"Invoice is not pending\");\n  }\n\n  const newInvoice: GoodInvoice = {\n    ...invoice,\n    state: \"paid\",\n    paymentMethod,\n    paidAt: new Date().toISOString(),\n  };\n\n  return newInvoice;\n}\n```\n\nGone are all the checks for `cancelledAt` and the like, as the compiler guarantees that it _cannot_ exist on an invoice in the pending state. It is impossible to make a mistake assuming you've defined your states correctly. But we can go further.\n\n```ts\nfunction payGoodInvoice(\n  invoice: GoodInvoicePending,\n  paymentMethod: string\n): GoodInvoicePaid {\n  const newInvoice: GoodInvoicePaid = {\n    ...invoice,\n    state: \"paid\",\n    paymentMethod,\n    paidAt: new Date().toISOString(),\n  };\n\n  return newInvoice;\n}\n```\n\nAnd just like that, we've made it impossible to pass a non-pending invoice to this function, you've transferred responsibility to ensure that an invoice is pending to the caller, and we've removed an exception/error (more on this later).\n\nIf we compare this to our original function, we've come a long way. We have added a lot of certainty to what we know about the data being given to and returned from our function and prevented mistakes. Not only does this prevent bugs, but it removes a log of cognitive load from you. You don't have to remember to check all the possible errors with the state, as it simply cannot be.\n\n## Error handling\n\nWe can only discuss representing all states if we include discussing error states. Traditionally we handle errors/exceptions (error from here on) with a `try/catch` statement. There are several issues with this approach:\n\n1. How do you know what functions might throw an error?\n2. How do you remember to `try/catch` these error-able functions?\n3. How do we recover from these errors?\n4. In some languages, the error in `catch (e)` is untyped or typed as `any`\n\nThe first problem is often dealt with using some kind of comment, such as `@throws`. This is a reasonable first attempt, but it only helps if you notice or remember it.\n\nThe second problem is rarely dealt with unless it is a core part of the language, such as Java's `throws X` syntax. Several languages return tuples with `(err, value)` in an attempt to remind you to check if there's an error before accessing the value. Java's (and others) approach is the only way to get the compiler to force you to handle the error.\n\nThe third problem is more complicated to address and will depend on your situation. But if you don't want to throw the error up the stack, you must find a way to return a \"good\" and \"bad\" value.\n\nThe fourth problem is egregious. Being untyped and relying on you to dance `e instanceof Error` is beyond problematic. If this is built into your language (looking at you, JavaScript and TypeScript), there's little you can do to resolve this other than do the dance.\n\nThis is a collection of rather sorry issues. Errors occur. It's the nature of life. A file might be corrupt, an API request might fail, or any number of other things might happen. So how do we address this?\n\n```ts\nexport type Ok<T> = {\n  ok: true;\n  value: T;\n};\n\nexport type Err<E> = {\n  ok: false;\n  error: E;\n};\n\nexport type Result<T, E> = Ok<T> | Err<E>;\n```\n\nIntroducting `Result`. Don't worry if you're not familiar with [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), you don't need to understand them for this. `Result` is a type that represents the return value of a function. It either worked and is `Ok` or errored and is an `Err`. \n\nWhy is this powerful? Let's look at an example.\n\n```ts\nenum FileReadingError {\n  FILE_NOT_FOUND,\n  FILE_NOT_READABLE,\n  // ...\n}\n\nfunction readFile(path: string): Result<string, FileReadingError> {\n  // ...\n  \n  return {\n    ok: true,\n    value: \"file content\",\n  };\n}\n```\n\nLooking at the `readFile` function, we immediately know 3 things, it can error, what it will return if it works, and what the error will be if it fails. This also resolves all of the issues highlighted previously. Let's say we wanted to print the contents of the file.\n\n```ts\nfunction printFile(path: string) {\n  const result = readFile(path);\n\n  if (!result.ok) {\n    switch (result.error) {\n      case FileReadingError.FILE_NOT_FOUND:\n        console.log(\"File not found\");\n        return;\n      case FileReadingError.FILE_NOT_READABLE:\n        console.log(\"File not readable\");\n        return;\n      default:\n        return;\n    }\n  }\n\n  console.log(result.value);\n}\n```\n\nThis function reads the file, and checks to see if the result is `Ok`. If it wasn't, it knows what the error type is and can respond correctly, or if it was, it can continue and print the contents.\n\nWhy is this powerful? Because the compiler, as before, can step in and ensure you handle the `Result` and let you know the error type. If you forget to check `result.ok`, you cannot access its value, and you'll get a compiler error like this:\n\n```\nProperty 'value' does not exist on type 'Result<string, FileReadingError>'.\n  Property 'value' does not exist on type 'Err<FileReadingError>'.\n```\n\nYou'll get a similar error if you try to access the error without checking it's errored. It is now impossible to get this wrong and forget a `try/catch` somewhere, and having the error type is immensely useful. Not only does it save you from the `instanceof` dance, you know at compile time what errors you might get and can handle all of them appropriately.\n\n### Api with Result\n\nThe only complication with this is when it comes to integrating this approach with non-result-friendly code. But we can get around that.\n\n```ts\ntype ApiErrorWithStatus = {\n  type: \"api_error_with_status\";\n  status: number;\n};\n\ntype UnknownApiError = {\n  type: \"unknown_api_error\";\n  message: string;\n};\n\ntype ApiError = ApiErrorWithStatus | UnknownApiError;\n\nasync function api<D>(url: string): Promise<Result<D, ApiError>> {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      return {\n        ok: false,\n        error: {\n          type: \"api_error_with_status\",\n          status: response.status,\n        },\n      };\n    }\n\n    const data = await response.json();\n\n    return {\n      ok: true,\n      value: data,\n    };\n  } catch (error) {\n    return {\n      ok: false,\n      error: {\n        type: \"unknown_api_error\",\n        message: error.message,\n      },\n    };\n  }\n}\n\ntype Trade = {\n  instrument: string;\n};\n\ntype Instrument = {\n  name: string;\n  price: number;\n};\n\ntype TradeWithPrice = Trade & {\n  price: number;\n};\n\ntype FetchTradeInstrumentNotFoundError = {\n  type: \"fetch_trade_instrument_not_found_error\";\n  instrument: string;\n};\n\ntype FetchTradeError = ApiError | FetchTradeInstrumentNotFoundError;\n\nasync function fetchTradesWithPrices(): Promise<\n  Result<TradeWithPrice[], FetchTradeError>\n> {\n  const trades = await api<Trade[]>(\"/api/trades\");\n\n  if (!trades.ok) {\n    return trades;\n  }\n\n  const instrumentNames = trades.value.map((trade) => trade.instrument);\n\n  const prices = await api<Instrument[]>(\n    `/api/prices?instruments=${instrumentNames.join(\",\")}`\n  );\n\n  if (!prices.ok) {\n    return prices;\n  }\n\n  const tradesWithPrices: TradeWithPrice[] = [];\n\n  for (const trade of trades.value) {\n    const instrument = prices.value.find(\n      (instrument) => instrument.name === trade.instrument\n    );\n\n    if (!instrument) {\n      return Err({\n        type: \"fetch_trade_instrument_not_found_error\",\n        instrument: trade.instrument,\n      });\n    }\n\n    tradesWithPrices.push({\n      ...trade,\n      price: instrument.price,\n    });\n  }\n\n  return {\n    ok: true,\n    value: tradesWithPrices,\n  };\n}\n```\n\nThis is a fairly complex example, but hopefully, it demonstrates what is possible. We have wrapped `fetch` in an `api` function that turns it into a promised `Result`. We then use it in `fetchTradesAndPrices` to call the API and either return trades prices or return errors early. Again with complete type safety and assurance that we've remembered to handle any and all errors. We've also combined the API errors with our own errors so that any call of `fetchTradesAndPrices` will have to consider missing price data and potential API errors. You could also transform all the errors into a generic `API_REQUEST_FAILED` if that's all you need to display to users.\n\n## Null\n\nMost languages now have the functionality to either enable strict-null-checking or have an `Option` type. I recommend using the language's built-in variants as they might have some advantages with compiler optimisation. If not, you can create an `Option` type similar to `Result` that forces you to check for null.\n\n```ts\nexport type Some<T> = {\n  some: true;\n  value: T;\n};\n\nexport type None = {\n  some: false;\n};\n\nexport type Option<T> = Some<T> | None;\n\nexport function Some<T>(value: T): Some<T> {\n  return {\n    some: true,\n    value,\n  };\n}\n\nexport const None: None = {\n  some: false,\n};\n```\n\nThis is similar to `Result` in the way you have to check that `x.some` is true before you can access the inner value, preventing you from accessing a null value. This eliminates the entire category of `NullPointerExcetion` errors.\n\n## Integrating with a database\n\nOne question you might have hanging around from our Invoice example is how to make it work with a database, as you almost certainly don't want to store each state on a separate table. So how do we keep the data consistent when building the states?\n\n```ts\ntype InvoicePending = {\n  uuid: string;\n  amount: number;\n  state: \"pending\";\n  createdAt: string;\n};\n\ntype InvoicePaid = {\n  uuid: string;\n  amount: number;\n  state: \"paid\";\n  createdAt: string;\n  paidAt: string;\n  paymentMethod: string;\n};\n\ntype InvoiceCancelled = {\n  uuid: string;\n  amount: number;\n  state: \"cancelled\";\n  createdAt: string;\n  cancelledAt: string;\n  cancelledReason: string;\n};\n\ntype Invoice = InvoicePending | InvoicePaid | InvoiceCancelled;\n\ntype DBInvoice = {\n  uuid: string;\n  amount: number;\n  state: \"pending\" | \"paid\" | \"cancelled\";\n  createdAt: string;\n  paidAt: string | null;\n  paymentMethod: string | null;\n  cancelledAt: string | null;\n  cancelledReason: string | null;\n};\n\nenum DBInvoiceParsingError {\n  UNKNOWN_STATE = \"UNKNOWN_STATE\",\n  PENDING_INVOICE_HAS_PAID_AT = \"PENDING_INVOICE_HAS_PAID_AT\",\n  PENDING_INVOICE_HAS_PAYMENT_METHOD = \"PENDING_INVOICE_HAS_PAYMENT_METHOD\",\n  PENDING_INVOICE_HAS_CANCELLED_AT = \"PENDING_INVOICE_HAS_CANCELLED_AT\",\n  PENDING_INVOICE_HAS_CANCELLED_REASON = \"PENDING_INVOICE_HAS_CANCELLED_REASON\",\n  PAID_INVOICE_MISSING_PAID_AT = \"PAID_INVOICE_MISSING_PAID_AT\",\n  PAID_INVOICE_MISSING_PAYMENT_METHOD = \"PAID_INVOICE_MISSING_PAYMENT_METHOD\",\n  PAID_INVOICE_HAS_CANCELLED_AT = \"PAID_INVOICE_HAS_CANCELLED_AT\",\n  PAID_INVOICE_HAS_CANCELLED_REASON = \"PAID_INVOICE_HAS_CANCELLED_REASON\",\n  CANCELLED_INVOICE_MISSING_CANCELLED_AT = \"CANCELLED_INVOICE_MISSING_CANCELLED_AT\",\n  CANCELLED_INVOICE_MISSING_CANCELLED_REASON = \"CANCELLED_INVOICE_MISSING_CANCELLED_REASON\",\n  CANCELLED_INVOICE_HAS_PAID_AT = \"CANCELLED_INVOICE_HAS_PAID_AT\",\n  CANCELLED_INVOICE_HAS_PAYMENT_METHOD = \"CANCELLED_INVOICE_HAS_PAYMENT_METHOD\",\n}\n\nfunction dbInvoiceToInvoice(\n  dbInvoice: DBInvoice\n): Result<Invoice, DBInvoiceParsingError> {\n  switch (dbInvoice.state) {\n    case \"pending\": {\n      if (dbInvoice.paidAt !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PENDING_INVOICE_HAS_PAID_AT,\n        };\n      }\n      if (dbInvoice.paymentMethod !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PENDING_INVOICE_HAS_PAYMENT_METHOD,\n        };\n      }\n      if (dbInvoice.cancelledAt !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PENDING_INVOICE_HAS_CANCELLED_AT,\n        };\n      }\n      if (dbInvoice.cancelledReason !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PENDING_INVOICE_HAS_CANCELLED_REASON,\n        };\n      }\n\n      return {\n        ok: true,\n        value: {\n          uuid: dbInvoice.uuid,\n          amount: dbInvoice.amount,\n          state: \"pending\",\n          createdAt: dbInvoice.createdAt,\n        },\n      };\n    }\n    case \"paid\": {\n      if (dbInvoice.paidAt === null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PAID_INVOICE_MISSING_PAID_AT,\n        };\n      }\n      if (dbInvoice.paymentMethod === null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PAID_INVOICE_MISSING_PAYMENT_METHOD,\n        };\n      }\n      if (dbInvoice.cancelledAt !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PAID_INVOICE_HAS_CANCELLED_AT,\n        };\n      }\n      if (dbInvoice.cancelledReason !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.PAID_INVOICE_HAS_CANCELLED_REASON,\n        };\n      }\n\n      return {\n        ok: true,\n        value: {\n          uuid: dbInvoice.uuid,\n          amount: dbInvoice.amount,\n          state: \"paid\",\n          createdAt: dbInvoice.createdAt,\n          paidAt: dbInvoice.paidAt,\n          paymentMethod: dbInvoice.paymentMethod,\n        },\n      };\n    }\n    case \"cancelled\": {\n      if (dbInvoice.cancelledAt === null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.CANCELLED_INVOICE_MISSING_CANCELLED_AT,\n        };\n      }\n      if (dbInvoice.cancelledReason === null) {\n        return {\n          ok: false,\n          error:\n            DBInvoiceParsingError.CANCELLED_INVOICE_MISSING_CANCELLED_REASON,\n        };\n      }\n      if (dbInvoice.paidAt !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.CANCELLED_INVOICE_HAS_PAID_AT,\n        };\n      }\n      if (dbInvoice.paymentMethod !== null) {\n        return {\n          ok: false,\n          error: DBInvoiceParsingError.CANCELLED_INVOICE_HAS_PAYMENT_METHOD,\n        };\n      }\n      return {\n        ok: true,\n        value: {\n          uuid: dbInvoice.uuid,\n          amount: dbInvoice.amount,\n          state: \"cancelled\",\n          createdAt: dbInvoice.createdAt,\n          cancelledAt: dbInvoice.cancelledAt,\n          cancelledReason: dbInvoice.cancelledReason,\n        },\n      };\n    }\n    default:\n      return {\n        ok: false,\n        error: DBInvoiceParsingError.UNKNOWN_STATE,\n      };\n  }\n}\n```\n\nOk, this looks like a lot, and you might be thinking, \"ah ha, see, you have having to check for possible invalid states!\". Yes, we have to check for invalid states when importing non-validated states into our validated states code, but this is the _only_ time we'll need to do it. If we're going to do these checks, then I believe this is the best place for it, as this will likely be in or adjacent to your database/repository code, so you will be thinking about all the possible states and data you need to be aware of. There's also a less verbose way to write this. I'll leave that as an exercise to the reader.\n\nThis function provides a single point for a non-validated state to become valid with helpful error handling. You might be thinking, \"but what if it's in an in-between state, it should coerce it to a valid state\". I know this is tempting, but you must avoid this thinking. If the \"in-between\" state was valid, you would have represented it in your initial definition. It should not be possible for the data in the database to not represent one of these valid states. If it does not, you should treat the data as corrupted and go down that recovery route. \n\nThere are many better options available to you than compromising the safety of your states. One such choice could be to present the user with a \"Something went wrong\" view and have the system raise an urgent ticket to manually review the account and correct the error. As cumbersome and slow as this might seem, and as tempting to say, \"but it can self recover from this error\", remember, your code could not have inserted this invalid state into the database. Therefore it should not have come out invalid. If it is invalid, it is either corrupted or something has tampered with the data. In either case, the computer can not be expected to make the correct rectification by itself and might, in turn, make the problem worse and harder to track and fix when you inevitably have to intervene.\n\n> If you are unable to load a valid state from a data, you should treat it as though the integrity of the data has been lost and should not try to automatically recover from it\n\n## Combining Valid States\n\nWhile this invoice example is fine in isolation, combining it with other valid states becomes even more powerful.\n\n```ts\ntype AccountSignup = {\n  uuid: string;\n  state: \"signup\";\n  email: string;\n};\n\ntype AccountTrial = {\n  uuid: string;\n  state: \"trial\";\n  email: string;\n  password: string;\n  trialStartAt: string;\n  trialEndsAt: string;\n};\n\ntype AccountActive = {\n  uuid: string;\n  state: \"active\";\n  email: string;\n  password: string;\n  paymentMethod: string;\n  currentInvoice: InvoicePending | InvoicePaid;\n};\n\ntype AccountCancelled = {\n  uuid: string;\n  state: \"cancelled\";\n  email: string;\n  password: string;\n  currentInvoice: InvoiceCancelled;\n  cancelledAt: string;\n  cancelledReason: string;\n};\n\ntype Account = AccountSignup | AccountTrial | AccountActive | AccountCancelled;\n```\n\nWith this, you have defined some core business logic, embedded it as valid states, and the compiler will now hold you to these guarantees. \n\n1. To become a trial account after signup, it must:\n\t1. Have set a password\n\t2. Have a trial start and end date\n2. To become active, the account must:\n\t1. Have a payment method set\n\t2. A pending or paid invoice\n\t3. Not be on trial\n3. To cancel an account, you must:\n\t1. Delete the payment method\n\t2. Have a cancellation date and reason\n\nYou no longer have to consider, \"oh, did I remember to force an invoice cancelled when cancelling the account?\" or \"when I cancelled the invoice, did I remember to create a new pending one to replace it and save it?\". These concerns are now the concern of the compiler, and the compiler won't forget.\n\n> The compiler is smarter than you or me. The more information you give it, the fewer bugs you'll have and the less you have to think about\n\n## Another example\n\nBefore we move on to other concepts, it might be worth doing something non-finance-related to show you how it can be useful in different contexts.\n\n```ts\nconst REPORT_TYPE = {\n  STRUCTUAL: \"STRUCTUAL\",\n  GROUND: \"GROUND\",\n  RIVER: \"RIVER\",\n} as const;\ntype REPORT_TYPE = (typeof REPORT_TYPE)[keyof typeof REPORT_TYPE];\n\ntype PersonSurveyor = {\n  type: \"surveyor\";\n  uuid: string;\n  name: string;\n};\n\ntype PersonReviewer = {\n  type: \"reviewer\";\n  uuid: string;\n  name: string;\n};\n\ntype PersonManager = {\n  type: \"manager\";\n  uuid: string;\n  name: string;\n};\n\ntype Person = PersonSurveyor | PersonReviewer | PersonManager;\n\ntype UnassignedUnconfirmedReport = {\n  type: \"unassigned_unconfirmed\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n};\n\ntype AssignedUnconfirmedReport = {\n  type: \"assigned_unconfirmed\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n};\n\ntype AssignedConfirmedReport = {\n  type: \"assigned_confirmed\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n  date: string;\n  confirmedAt: string;\n  confirmedBy: PersonManager;\n};\n\ntype InProgressReport = {\n  type: \"in_progress\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n  date: string;\n  confirmedAt: string;\n  confirmedBy: PersonManager;\n  startedAt: string;\n};\n\ntype AwaitingReviewReport = {\n  type: \"awaiting_review\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n  date: string;\n  confirmedAt: string;\n  confirmedBy: PersonManager;\n  startedAt: string;\n  endedAt: string;\n};\n\ntype InReviewReport = {\n  type: \"in_review\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n  date: string;\n  confirmedAt: string;\n  confirmedBy: PersonManager;\n  startedAt: string;\n  endedAt: string;\n  reviewStartedAt: string;\n  reviewer: PersonReviewer;\n};\n\ntype CompletedReport = {\n  type: \"completed\";\n  reportType: REPORT_TYPE;\n  uuid: string;\n  assignedTo: PersonSurveyor;\n  assignedAt: string;\n  assignedBy: PersonManager;\n  date: string;\n  confirmedAt: string;\n  confirmedBy: PersonManager;\n  startedAt: string;\n  endedAt: string;\n  reviewStartedAt: string;\n  reviewer: PersonReviewer;\n  reviewEndedAt: string;\n  completedAt: string;\n};\n\ntype Report =\n  | UnassignedUnconfirmedReport\n  | AssignedUnconfirmedReport\n  | AssignedConfirmedReport\n  | InProgressReport\n  | AwaitingReviewReport\n  | InReviewReport\n  | CompletedReport;\n```\n\nThough this example is a little more complex, again, we've encoded a significant amount of business logic into our valid states, ensuring that we follow our own rules.\n\n1. A report starts out unassigned and unconfirmed\n2. A report must next be assigned to someone\n3. The report time must be confirmed before it can be started, and it must be confirmed by a manager\n4. A report must be finished and awaiting review before it can be reviewed\n5. A reviewer is the only person who can review a report\n6. A reviewer must complete a review before a report can be marked complete\n\nThese are some core business rules that previously might've been either a single large `progressToNextState` function that did a ludicrous amount of state validation and checking before progressing or a series of smaller functions littered all over the place. This trap is just waiting for you to forget to implement some business rule either when you first implement it or much later when changing something.\n\nIf you later decide that the surveyor can confirm the date themselves, you only need to change it in the state definition, and the compiler will tell you what else you need to change to reflect this change. \n\nOne limitation is that we cannot protect against moving between the states out of order. The easiest way around this is to have an internal rule (or better yet, a linter if possible and/or protected creators) preventing you from manually transitioning from one state to another, instead requiring you to use a series for functions that go from one state to the other.  \n\n```ts\nfunction assignReport(\n  report: UnassignedUnconfirmedReport,\n  assignedTo: PersonSurveyor,\n  assignedAt: string,\n  assignedBy: PersonManager\n): AssignedUnconfirmedReport {\n  return {\n    ...report,\n    type: \"assigned_unconfirmed\",\n    assignedTo,\n    assignedAt,\n    assignedBy,\n  };\n}\n```\n\nThis not only has the advantage of forcing states to progress in a specific order but also means that in this single function, we could produce any necessary events we want to dispatch and not have to remember to do it anytime we modify a report.\n\n## Exhaust\n\nYou may have noticed that I have a `default` case that returns an error in several of my switch statements. This is fine, but we can do better.\n\n```ts\nexport function exhaust(\n  _value: never,\n  message = \"Failed exhaustive check\"\n): never {\n  throw new Error(message);\n}\n```\n\nIf we use this as the default case for our switch statements, the compiler will not let us forget the variant and will force us to handle it. Yes, this function technically throws an error, and I've previously discussed why this is bad. This is an exception to that rule. While, in theory, it could throw the error, our type system prevents it, and if that code were to be reached, it would hint at a very unlikely compiler bug.\n\n```ts\ntype ReportA = {\n  type: \"A\";\n  a: string;\n};\n\ntype ReportB = {\n  type: \"B\";\n  b: string;\n};\n\ntype ReportC = {\n  type: \"C\";\n  c: string;\n};\n\ntype Report = ReportA | ReportB | ReportC;\n\nfunction processReport(report: Report) {\n  switch (report.type) {\n    case \"A\":\n      console.log(report.a);\n      break;\n    case \"B\":\n      console.log(report.b);\n      break;\n    default:\n      exhaust(report);\n  }\n}\n```\n\nThis example creates a compiler error of:\n\n```Argument of type 'ReportC' is not assignable to parameter of type 'never'```\n\nIt won't be happy until we write a case for `ReportC`. This might seem trivial in this case but consider larger applications. Take the example from before with the reports. There are likely multiple places where you'll be doing different things depending on the state/type of the report. If you add a new state/type to your report, you might forget somewhere it's used and end up with an invalid state in that code. Instead, using `exhaust` will raise an error everywhere you use the state/type and prevent you from forgetting to handle this new case. This could be anything from rendering styling to saving to the database.\n\n## Conclusion\n\nHopefully, you can now see how you can use your type system to your advantage. Why tolerate bugs caused by forgetfulness when you can have the compiler prevent them from ever getting past your editor?\n\nIn some languages, you might have to use a static analyser as part of your continuous integration rather than just the compiler, but that should not be a reason to not use this technique. \n\nThis approach is a bit verbose compared to what you might currently be writing, but I'd argue that the upfront cost is worth the lifetime of bug prevention you will gain. I recommend you play around with this technique and try converting some of your existing code. You might be surprised how many bugs it'll catch and tell you about.",
      "tags": [
        "Programming"
      ],
      "hero": {
        "src": "https://cdn.geekyaubergine.com/2023/83bbe743c32.png",
        "alt": "Screen shot of 3 lines of code. The first line reads \"export type Ok<T> = { ok: true; value: T }\", the second line reads \"export type Err<E> = { ok: false; error: E }\" and the third line reads \"export type Result<T, E> = Ok<T> | Err<E>\"",
        "date": "2023-06-23T17:00:00.000Z",
        "parentPermalink": "/blog/leveraging-your-type-system",
        "width": 630,
        "height": 340,
        "orientation": "landscape",
        "title": null
      },
      "images": []
    },
    "hack-pompey-2023": {
      "key": "hack-pompey-2023",
      "permalink": "/blog/hack-pompey-2023",
      "title": "Hack Pompey 2023 - Blahbarian",
      "date": "2023-03-25T22:30:00.000Z",
      "description": "I attended my first hackathon, and we made a game about a Norwegian barbarian shark who destroys furniture using TypeScript and canvas.",
      "content": "![Two pixel art blue sharks wearing a barbarian horned had and a white shield with blue cross and red edging](https://cdn.geekyaubergine.com/2023/04572345cced.png)\n\nI attended my first hackathon hosted by [Hack Pompey](https://hackpompey.co.uk/), and it went well. \n\ntldr: We made a [Vampire Survivors](https://store.steampowered.com/app/1794680/Vampire_Survivors/) style game based around Blahai the Blahbarian\n\nYou can [play it here](https://zoeaubert.me/projects/blahbarian-hackathon/). Warning that the noises are pretty loud.\n\nThe code is available on [Github](https://github.com/GeekyAubergine/blahbarian/tree/hackathon).\n\n## The Team\n\n- [Char](https://github.com/bl-kt) - Blahbarian and weapon pixel art\n- [Charlie](https://social.lol/@tldrqwerty) - Programming\n- [Emily](https://emilymedhurst.me/) - Programming\n- [Finn](https://github.com/PeacefulAndTranquil) - Enemy pixel art\n- [Luke](https://github.com/LukeAustin8) - Programming\n- [Robb](https://robbknight.me) (Remote) - Sound\n- Me - Programming\n\n## The Plan\n\nCalling it a plan might be a bit of a stretch. My colleagues and I decided to team up when we decided to all go to the hackathon. We didn't know what we wanted to do and were hoping to find some inspiration when we got there. In the office, we have a [Blahaj](https://www.ikea.com/gb/en/p/blahaj-soft-toy-shark-30373588/), and it's been the centre of a few shenanigans. In a moment of inspiration, I came up with the idea of:\n\n> Blahaj tower defence. The shark shoots boxes at furniture to flat-pack it.\n\nThis got everyone's attention. We quickly transitioned away from Blahaj and decided to move to Blahai, the legally distinct shark. We discussed the game style, and after floating over a few, including a platformer, we decided to go with a [Legend of Zelda](https://en.wikipedia.org/wiki/The_Legend_of_Zelda_(video_game)) style dungeon/room-based game.\n\nTo play into the joke some more, we decided to make the Blahai Norwegian and make him a barbarian who destroys furniture. Emily then suggested \"Blahbarian\", and we immediately knew this was what we must do.\n\n## The Day\n\nA rough outline of the day was:\n\n- 10:15 - 13:00 - Programming\n- 13:00 - 13:45 - Lunch\n- 13:45 - 16:00 - Programming\n- 16:00 - 17:00 - Presentations\n\nWe were likely to get a little under 5 hours of programming in. This was much shorter than I anticipated and was barely enough to finish.\n\nAs is standard, we were delayed at the start with internet issues, which caused us to lose about 15 mins at the start trying to get the repo cloned.\n\nOnce we got that going, we got [Vite](https://vitejs.dev/) installed for easy Typescript compiling and some other nice tooling. This then allowed me to quickly get a framework set up and rendering to the canvas for the others to work with. As I was building the framework, Charlie suggested we move to an even simpler game design of something more similar to Vampire Survivor (linked above). We all agreed this would be much simpler, and it turned out to be an excellent suggestion.\n\nBy lunchtime, we had the world, player and entities rendering, and the player could move around. The sprite sheet rendering was the first two frames of the walking animation.\n\nAfter lunch, it was a bit of a sprint as we knew just how much we had left to do. We finalised how the sprite sheets worked to allow for animations and got them working directionally. Added spawning for enemies and basic \"go to player\" \"AI\". Added sounds. Added powerups. And finally, just before the presentation, we added attacking and attack animations.\n\nThe presentation went well, it didn't immediately fail, and we got through it in one piece. We came 3rd place in the community vote.\n\nOverall it was a great experience. It wasn't stressful per se, but very draining. I look forward to doing it again and maybe participating in a game jam in the future.\n\n## Engine design\n\nHaving dabbled in game building before, I had a plan of how it would work, which saved us a bunch of time. The core of the engine is simple.\n\nThe rendering would be handled by canvas. As the game was taking place on a flat plane, it made sense to centre the camera on the player and render everything relative to that. For the floor, this required rendering a simple grid of tiles relative to the player and ensuring the grid was one tile wider than the viewport. \n\nAll entities were given a movement enum of 'IDLE', 'DOWN', 'UP', 'LEFT', and 'RIGHT' to allow us to render appropriately rotated sprites and then rendered on the canvas relative to the player. Animations were handled by looping through an array of sprite keys that referenced the sprite sheets and rendering the sprite. The animations were then tied to the movement enum to allow it to swap out the correct sprites depending on movement.\n\nDamage dealing and collisions were handled by checking collisions on axis-aligned bounding boxes.\n\n## What I'd do differently\n\nOverall there's not a lot I'd do differently. The only part of the code I'm unhappy with is the animation system, as it's hard to trigger an animation and have it complete without a silly hack. For example, the sword swing takes longer than the player is pressing the key down for, so the boolean controlling its rendering is on a timeout rather than waiting for the last frame. It also doesn't always start from frame 0. I'm unsure how I'd address this without building a much more complex system than the time would've allowed.",
      "tags": [
        "Programming",
        "GameDev",
        "Hackathon"
      ],
      "hero": {
        "src": "https://cdn.geekyaubergine.com/2023/04572345cced.png",
        "alt": "Two pixel art blue sharks wearing a barbarian horned had and a white shield with blue cross and red edging",
        "date": "2023-03-25T22:30:00.000Z",
        "parentPermalink": "/blog/hack-pompey-2023",
        "width": 256,
        "height": 128,
        "orientation": "landscape",
        "title": null
      },
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2023/04572345cced.png",
          "alt": "Two pixel art blue sharks wearing a barbarian horned had and a white shield with blue cross and red edging",
          "date": "2023-03-25T22:30:00.000Z",
          "parentPermalink": "/blog/hack-pompey-2023",
          "width": 256,
          "height": 128,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "saving-my-chaos-knight": {
      "key": "saving-my-chaos-knight",
      "permalink": "/blog/saving-my-chaos-knight",
      "title": "Saving my Chaos Knight",
      "date": "2023-01-29T22:04:00.000Z",
      "description": "During my recent house move I managed to snap the lance off of one of my Chaos Knights. Though some stressful drilling I was able to save it.",
      "content": "Packing for my recent house move was a stressful process. Not only was it time-consuming, but some models required extra attention. I've always been worried about the structural integrity of the lances on the [Chaos Knights](https://www.games-workshop.com/en-GB/slaves-to-darkness-chaos-knights-2023) (slightly different set to mine, but you'll hopefully get my points). This concern was justified.\n\nMy friend recently asked if I was still playing [Age of Sigmar](https://ageofsigmar.fandom.com/wiki/Age_of_Sigmar_Wiki), which led me to pull my [Slaves to Darkness](https://www.warhammer-community.com/2019/12/03/faction-focus-slaves-to-darknessgw-homepage-post-2/) collection back out. I then discovered that one of the lances on a knight had broken off.\n\n![Assembled but not primed Slaves to Darkness Chaos Knight model facing the camera. It's lance is snapped at the handle and is next to the model. In the background are other completed Chaos Knight models on a green and yellow cutting mat, with some tools to the right-hand side](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2625.JPG)\n\nI initially considered trying to glue the lance back on, but the contact point was, at best, 2mm in diameter. If it did stick, it'd just snap again immediately. So I did the only logical thing and reached for my pin vice.\n\nI planned to use a brass rod to pin the parts in place. Having only ever used this technique to pin models to bases/cork before, this was a scary prospect. Especially considering the margin for error of misaligning the drill bit and coming out the side of the model was high.\n\nI tackled the scary part first and drilled directly into the hand and handle assembly. For reference, the drill bit I used was 0.7mm in diameter.\n\n![Me holding a Slaves to Darkness Chaos Knight model in side profile. The lance has snapped off at the handle. I am using a pin vice with a 0.7mm diameter drill bit to drill into the handle of the lance, which is approximately 2mm in diameter. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2627.JPG)\n\nThis went better than I expected, I half expected to destroy the whole hand and handle, but it survived. Unfortunately, it did make a bit of a mess of the hand, and when half a finger gave way, it made the entrance to the hole much larger than expected.\n\n![Me holding a Slaves to Darkness Chaos Knight model facing the camera on its side. I have drilled a hole into the lance's handle where it snapped off. The entrance to the hole has collapsed, resulting in it being wider than I'd like. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2636.JPG)\n\nDrilling the lance went much more smoothly.\n\n![Me holding a Slaves to Darkness Chaos Knight lance with the tip facing away from the camera showing the 0.7mm hole I've just drilled to pin it to the model. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2635.JPG)\n\nNext came the pinning. I use 0.7mm outer diameter brass tubing. It might not be the best, but it's what I had. I initially forgot how soft the rod was and immediately bent it while pushing it into the hole. This took several attempts to get right with many bent and snapped pieces of brass.\n\n![Me holding a Slaves to Darkness Chaos Knight side on. The lance has been broken off and in its place is a 0.7mm brass rod that I'm going to use to pin the lance back in place. The entrance to the hole the brass is sat in is misshapen and is wider than the rod. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2641.JPG)\n\nOnce I got a rod in safely, I noticed that it wobbled significantly due to the issue noted earlier, where the entrance to the hole had given way. This was problematic and could not be saved with glue. In a moment of inspired brilliance, I decided to try pushing an offcut of a rod into the hole. This resolved this issue, though there were a few tense moments where the plastic felt like it would give way completely. Sorry about the quality. It looked fine when I took it. I missed the focus, but you can see the smaller bit at sicking out.\n\n![Zoomed in picture of me holding a Slaves to Darkness Chaos Knight. The picture is focused on the handle where the lance should be. In its place is a long brass rod with another brass rod in the same hole to provide support.](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/Screenshot-2023-01-29.png)\n\nOnce I'd got that in place and got it settled, applying some glue on the hand and pushing the lance down onto the rod was simple. It did require holding in place a bit while it dried, as the rod wasn't perfectly aligned for both halves.\n\nAll things considered, I'm pleased with how this turned out. It's a little wonky, but you'd have to be looking for it. And when surrounded by other Knights, it fits in well. It does make me worry about the safety of this and the other models. Though I will be getting more regardless because this is a fantastic model.\n\n![Slaves to Darkness Chaos Knight in a top-down side-on perspective. In the background is a green and yellow cutting mat, several other models and some tools](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2656.JPG)\n\n![Slaves to Darkness Chaos Knight in low side-on perspective to highlight slight bend in the lance. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2654.JPG)\n\n![Slaves to Darkness Chaos Knight in top-down perspective to highlight slight bend in the lance. In the background is a green and yellow cutting mat and several other models](https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2653.JPG)\n",
      "tags": [
        "Warhammer",
        "AgeOfSigmar",
        "SlavesToDarkness"
      ],
      "hero": {
        "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2656.JPG",
        "alt": "Slaves to Darkness Chaos Knight in a top-down side-on perspective. In the background is a green and yellow cutting mat, several other models and some tools",
        "date": "2023-01-29T22:04:00.000Z",
        "parentPermalink": "/blog/saving-my-chaos-knight",
        "width": 800,
        "height": 600,
        "orientation": "landscape",
        "title": null
      },
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2625.JPG",
          "alt": "Assembled but not primed Slaves to Darkness Chaos Knight model facing the camera. It's lance is snapped at the handle and is next to the model. In the background are other completed Chaos Knight models on a green and yellow cutting mat, with some tools to the right-hand side",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2627.JPG",
          "alt": "Me holding a Slaves to Darkness Chaos Knight model in side profile. The lance has snapped off at the handle. I am using a pin vice with a 0.7mm diameter drill bit to drill into the handle of the lance, which is approximately 2mm in diameter. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2636.JPG",
          "alt": "Me holding a Slaves to Darkness Chaos Knight model facing the camera on its side. I have drilled a hole into the lance's handle where it snapped off. The entrance to the hole has collapsed, resulting in it being wider than I'd like. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2635.JPG",
          "alt": "Me holding a Slaves to Darkness Chaos Knight lance with the tip facing away from the camera showing the 0.7mm hole I've just drilled to pin it to the model. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2641.JPG",
          "alt": "Me holding a Slaves to Darkness Chaos Knight side on. The lance has been broken off and in its place is a 0.7mm brass rod that I'm going to use to pin the lance back in place. The entrance to the hole the brass is sat in is misshapen and is wider than the rod. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/Screenshot-2023-01-29.png",
          "alt": "Zoomed in picture of me holding a Slaves to Darkness Chaos Knight. The picture is focused on the handle where the lance should be. In its place is a long brass rod with another brass rod in the same hole to provide support.",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 1056,
          "height": 1016,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2656.JPG",
          "alt": "Slaves to Darkness Chaos Knight in a top-down side-on perspective. In the background is a green and yellow cutting mat, several other models and some tools",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2654.JPG",
          "alt": "Slaves to Darkness Chaos Knight in low side-on perspective to highlight slight bend in the lance. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/saving-my-chaos-knight/IMG_2653.JPG",
          "alt": "Slaves to Darkness Chaos Knight in top-down perspective to highlight slight bend in the lance. In the background is a green and yellow cutting mat and several other models",
          "date": "2023-01-29T22:04:00.000Z",
          "parentPermalink": "/blog/saving-my-chaos-knight",
          "width": 4032,
          "height": 3024,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "2022-a-year-in-review": {
      "key": "2022-a-year-in-review",
      "permalink": "/blog/2022-a-year-in-review",
      "title": "2022 A Year In Review",
      "date": "2023-01-08T16:10:00.000Z",
      "description": "A look back over my 2022",
      "content": "2022 has been a year of significant change for me. I've wanted to write this since the summer when I thought of this title. I was considering borrowing the style from [Robb Knight](https://rknight.me/just-2022-things/)'s and [Sophie](https://localghost.dev/blog/2022-the-year-in-lists/)'s posts, but much like my journalling, I find lists restrictive (more on this later in the journaling section), so I chose to do it this way instead.\n\n## Buying my house\n\nAt the start of 2022, I was renting a little one-bed flat. I intended to buy something at some point, but it wasn't really on my mind. Much to my surprise, towards the end of January, my landlord contacted me asking if I wanted to buy the flat. After initially going for it, I ended up pulling out due to a myriad of issues; this then started the search for somewhere else. I initially began looking for somewhere to rent, assuming I would receive my notice shortly. After lamenting my annoyance at having to rent again with my boss, he suggested that I look to buy and just sofa surf between places if I need to. Despite my initial reservations, this made sense.\n\nThe search increased from there, and I started reviewing property listings hourly and phoning them immediately for viewings. Despite this, I could not view all the properties I wanted to, such was the market's craziness at the time. All in all, I viewed in the order of 30 properties and offered on 3 before finally having an offer accepted.\n\nThankfully, as I'd been in the process of purchasing the flat, I had most of my anti-money-laundering and other checks in place, so I was able to complete in a speedy 84 days. The process of completing was surprising. After weeks of back and forth with lots of people, to then be given the keys and be left alone was a stark difference. Going from a tiny flat to being entirely responsible for a house was, and still is, a little overwhelming at first, but it's slowly sinking in. Overall it was an exciting and stressful experience, but I'm happy with how it worked out.\n\n## Warhammer\n\nIn 2021 I started to pick up Warhammer again, slowly working my way through one of the starter sets I'd picked up many years ago (Tempest of Souls, for those curious). As I was expanding my [Nighthaunt](https://ageofsigmar.fandom.com/wiki/Nighthaunt) collection, I grew a bit tired of painting ghosts despite my love of the lore and gave [Slaves to Darkness](https://ageofsigmar.lexicanum.com/wiki/Slaves_to_Darkness). A little later in the year, I ended up going to a party and found out a friend had some [Space Marines](https://warhammer40k.fandom.com/wiki/Space_Marines) and [Necrons](https://warhammer40k.fandom.com/wiki/Necrons) he'd got in a starter pack. This spawned a discussion that led me to look into [40k](https://warhammer40k.fandom.com/wiki/Warhammer_40k_Wiki) and eventually give it a try. I was torn between trying [Space Marines](https://warhammer40k.fandom.com/wiki/Space_Marines) and [Tyranids](https://warhammer40k.fandom.com/wiki/Tyranids), but I ended up picking the Space Marines as I didn't fancy doing another \"horde\" army.\n\nPicking Space Marines only increased my analysis paralysis. I couldn't decide what [Chapter](https://warhammer40k.fandom.com/wiki/Chapter) to pick. I love the [Imperial Fists](https://warhammer40k.fandom.com/wiki/Imperial_Fists)' lore and style, but their rules and painting that much yellow dissuaded me. I eventually decided to go for a custom chapter and settled on a lovely purple scheme after trying _lots_ of different colours.\n\nTo learn more about 40k, I started reading (listening) to some [books](https://geekyaubergine.com/categories/books/), and it was all going well until one of the last [Ciaphas Cain](https://warhammer40k.fandom.com/wiki/Ciaphas_Cain) books and [The Devastation of Baal](https://geekyaubergine.com/2022/09/14/finished-reading-the.html). These books (particularly the latter) focus on the [Tyranids](https://warhammer40k.fandom.com/wiki/Tyranids), and to say it captured my attention would be putting it lightly. So I ended up also picking up a Tyranids starting set and am currently [stuck picking a colour scheme](https://geekyaubergine.com/2022/08/14/finally-got-round.html).\n\nOn top of all this, I also decided to participate in a [Painting Competition](https://geekyaubergine.com/categories/painting-competition-2022/). So far hasn't gone very well, but as it's for a friend, I intend to finish this project before starting any new ones (we'll see how long that lasts).\n\n## Obsidian and Journaling\n\nThis year I stumbled upon [Obsidian](https://obsidian.md/), and I cannot stress how useful this tool has been. The ability to write something down and file it away and not have to keep all the details in my working memory has been a vast improvement.\n\nNow, whenever I'm researching/learning something, I will open a note about it, jot things down, and link it. I can't say how useful this is bar basic re-enforcement but even that's a major plus. I really wish I'd had something like this at university.\n\nI've not followed this religiously, and there are many things I should've taken notes on, so my graph could be more impressive, but what I have so far makes me happy. I am aware this might fall into the \"feeling productive without really being productive\" category.\n\n![Screenshot of obsidan graph](https://cdn.geekyaubergine.com/2023/2022_year_in_review/2022-obsidian-graph.png)\n\nI also have a note called \"inbox\". This is where I stick _any and all_ links to anything I find interesting for me to review later. I used to try and remember things, and writing them down and not worrying about forgetting them is easily the biggest win for me so far.\n\n### Journaling\n\nSomething else that Obsidian has given me is a journaling solution that works for me. I've tried it numerous times but never stuck with it for more than a short period. I think what clicked for me was:\n\n1. It's digital and private (no questionable cloud storage)\n2. I can link to notes\n3. I can link to people\n\nOnce I realised I could have notes for people and link to them in my daily notes, I was hooked. This was further enhanced when I started linking them to each other, interests, places of work, and social groups.\n\nI often struggle to remember people and things about them. Now, if I know I'm going to a social event, I can find the note for that social event and quickly review people's interests. It's prevented a few \"oh, I'd forgotten that\" moments and allowed for more flowing conversation.\n\nFor an example of why I think this is powerful, see this graph where I've unhidden the \"people\" (pink) and \"journal\" (yellow) notes. The purple ones are social events/groups. It shows how deeply connected both my journal, and people's notes are to everything I do.\n\n![Screenshot of obsidan graph](https://cdn.geekyaubergine.com/2023/2022_year_in_review/2022-obsidian-graph-full.png)\n\nLater in the year, I noticed I was journaling less and less again and wasn't sure why. I have a template I use for my notes, and the way I'd designed it was groups of lists such as \"what went well\", \"what was bad\", and \"reflections\". This led to very restricted and \"stiff\" journaling where I'd just list things and not actually talk about them. As a result, I never really got my thoughts or emotions down on paper and removing them from my mind. Once I realised this, I completely redesigned my template to be much less restrictive.\n\n```md\n# {{title}}\n\n## Season Theme:\n\n## Your day:\n\n## What are you grateful for?\n```\n\nSince changing this my journaling has improved vastly, I write more, I remember more, and I feel better for it.\n\nI also stumbled across [CGP Grey's Theme Video](https://www.youtube.com/watch?v=NVGuFdX5guE) again and decided to add that to my template, which has been a fun experiment. I'm not sure how much it helps me, but it reminds me of what I'm trying to achieve.\n\n## Health\n\nThis has been an unpredictable year for my health. At the start of the year, I made some rules for myself, which could be grouped into a broader category of \"not consuming so much crap\".\n\nThis was a good start, and to keep me on track, I downloaded an app to monitor the number of days since I last broke a rule. I do well when I gamify aspects of my life, and losing the big streaks helped a lot.\n\nI followed my rules for a while until the house purchase stress caused me to fall off the rails a bit. An added benefit I didn't expect was the money I would save, despite the ridiculously high cost of soft drinks at bars.\n\nNot long after the clocks changed, I decided, on a whim, to try running. I've never been an active person, and I've always particularly hated running, so this was a strange whim. And, I must admit, to my great surprise, I enjoyed it. Since then, I've run on and off 3 times a week and even invested in some running shoes (go to a good shop, it's helpful). I can say, without a doubt, that running and weight loss made me feel better than I have in a long time. I wasn't setting any records, but I felt good and was improving.\n\nIn the end, before the house stress entered my life, I lost about 9kg and was very close to being the lightest I've been in my adult life. While I still have a lot to go to reach my goal weight, this a milestone I very much look forward to coming close to and breaking again this year. Unfortunately, with the house stress, I gained back almost everything I'd lost, but I know I can lose it and look forward to getting back on it.\n\nI also caught covid at the start of the year, funnily enough, 2 weeks after my booster. Overall, not good, wouldn't recommend it. Final review: 0/10, would not cough again.\n\n## Music\n\nAfter a significant break of no music due to covid, 2022 was really the first full year of music, and it was a wild ride.\n\nOne of the groups I'm in performed [The Grand Duke](https://en.wikipedia.org/wiki/The_Grand_Duke) as a show for 4 days with 5 performances. It went surprisingly well considering the time since the last performance of that magnitude. But, it did result in half the group getting covid.\n\nDuring the summer, I was asked to play at a [mass](https://geekyaubergine.com/2022/06/11/nice-view-from.html). Having never been to a Catholic ceremony before, it was very educational, if not hard, to play while choking on incense. Interestingly was also my first official paid gig (unless you count food and drinks as \"proper\" payment), which now makes me a \"professional\".\n\nAfter the summer break, another group I'm in had no French horns. I've always fancied one, so I decided to use the gap and fill it, so I [got one](https://geekyaubergine.com/2022/10/30/after-many-years.html). This has been a humbling experience. Having to start from almost 0 again was challenging. To add to this challenge I only gave myself 6 weeks to learn it before my [first performance](https://geekyaubergine.com/2022/12/10/very-good-acoustics.html) with it, and for added fun, I had to swap between French horn and Trumpet for it. Overall I'm pleased with how far I've gone with it and look forward to seeing how comfortable I am with it in a year's time.\n\n## Programming\n\nAt the start of the year, I decided to give [Rust](https://www.rust-lang.org/) a go, a decision that has impacted me deeply.\n\nRust promised something I strive for, fewer bugs and more safety. This might be a slight bending of the truth, but that is how I saw the promises Rust made. These aspects are essential to me as I regularly get frustrated with the frequency of bugs and the lack of proper tools to prevent them. In many other languages, I emulate this by using highly modularised code, written as functionally as possible, immutable data structures and lot and lots of tests with good coverage. But it feels lacking compared to the tools Rust provides.\n\nAfter messing around with it and getting bullied by the borrow checker, I started working on some more \"serious\" and larger projects. It was also around this time that I stumbled across [NoBoilerplate](https://www.youtube.com/@NoBoilerplate)'s fantastic Rust videos that introduced me to the power of Rust's type system and \"correctness\". This, combined with [Result](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) and [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) types demonstrated how a compiler can do a lot of the work for you if you give it a lot of information.\n\nAs you might've guessed, I fell in love with this and talked about it a lot, much to my friends and colleagues' annoyance. Unfortunately, I can't move all my projects to Rust, so I had to make do. We have moved a few of them that I work on to Typescript, which has allowed me to implement both `Result` with a custom error definition and [Typestate](https://en.wikipedia.org/wiki/Typestate_analysis) for internal APIs. Unfortunately, we can't use Option as you'd have to do something special with `JSON.seralize` to make it work. Applying these techniques has:\n\n1. Improved my confidence in the projects\n2. Highlighted a significant number of bugs\n3. Allowed us to focus on correctness vs bug fixing\n4. Reduced the time spent writing tests for errors that the compiler now enforces behaviours for\n\nI might be falling into the trap of feeling productive again. But this type of safety and correctness makes me feel much better about the quality of the code I produce. And while I don't use it professionally, Rust has provided me with knowledge and tools I could use regardless.\n\n### Privacy Concerns\n\nDuring this year, I also became much more privacy-conscious. I made efforts on all my projects to protect users where possible. For me, the big change was dropping Google Analytics and Google Fonts. I was recommended (and would recommend) [Fathom Analytics](https://usefathom.com/ref/YQXCXP) as a replacement for analytics, and I found [Bunny Fonts](https://fonts.bunny.net/) to be a suitable replacement for fonts. Both are easy to use and do what I wanted them to do.\n\n## Social Media\n\nAs outlined in my [leaving Twitter](https://zoeaubert.me/blog/leaving-the-twitter-nest) post I'm not, or at least wasn't, one for social media or posting in general. I rarely posted more than a few times a year and often less. More often than not, I was retweeting funny things or getting angry with the state of the world.\n\n### Micro.blog\n\nWith people leaving for greener pastures, I took it as an opportunity to re-evaluate my position within the social media world. I was first told about [Micro.blog](https://micro.blog) by [Robb Knight](https://rknight.me/), we discussed it a few times before I gave it a go, and I'm glad I did. The community is friendlier, and the lack of likes and a retweeting equivalent lends itself to much more \"intentionality\" rather than chasing interaction.\n\nAs [Robb](https://rknight.me/thoughts-on-micro-blog/) put it:\n\n> Micro.blog ... has no likes, no follower counts, no retweets, and no ~~post dunking~~ quote tweets. If I post something, I don't know who saw it or who enjoyed it but it doesn't matter; I'm posting it because I want to ... but none of it is being posted to try and \"go viral\" or get likes.\n\nIt was weird at first, posting and not getting instant likes, but posting just for yourself is fun. One of the many things that put me off posting on other platforms was it'd be shoved in people's faces, so I felt the need to perform. Here, I post what I like and only know if someone enjoyed or even saw it if they take the time to reply.\n\n### Instagram\n\nSimilar to Twitter I hadn't posted on Instagram in a long time, primarily due to the \"x has posted for the first time in y\" notification people get. Not only does this highlight that you've not posted a lot, but it also leads people to mindlessly like your posts as a performance, which is worse than no interaction. Again Micro.blog + my website filled the gap for me with minimal effort.\n\n### Mastodon\n\nI originally intended to avoid Mastodon, but after freeing myself of the Twitter curse, I decided not to engage with a similar platform. I still think this way, but after (again) [Robb](https://toot.rknight.me/2022/12/26/only-a-few.html) spoke about [omg.lol](https://omg.lol) I thought I'd give it a look. I mainly got it for the Linktree-like pages [geekyaubergine.omg.lol](https://geekyaubergine.omg.lol), but it also comes with a Mastodon instance, so I thought I'd at least set it up.\n\nAt first, I was trying to figure out what to do with it. I'd got my replacements for the two platforms I used to post on, which left Mastodon feeling redundant. I started following people who'd moved to it previously and noticed similar behaviours that I wanted to avoid. [Andrew Canion's comment](https://micro.blog/canion/15017624) about treating Mastodon as ephemeral stuck with me. That, combined with [status.lol](http://status.lol) got me thinking and deciding to use it similarly. Though I'm already uncomfortable with the \"engagement\" statistics and notifications I've received.\n\n### So what now?\n\nThis is what I found myself asking towards the end of the year. What I settled on was:\n\n-   [zoeaubert.me](https://zoeaubert,me) for long posts\n-   [geekyaubergine.com](https://geekyaubergine.com) for almost a ledger of my life\n-   [Mastodon](https://social.lol/@geekyaubergine) for \"shorts\"\n\nI like this system for now, but I still have some concerns about Mastodon, but I'll try it for now.\n\nOne thing I learnt in moving away from other platforms is that getting your data is a pain (Micro.blog makes it very easy. So I'm wary of posting anything I care about to a platform where reclaiming it would be hard.\n\n## 2023\n\nSort of following the \"themes\" methodology, I'm refusing to commit to any resolutions passed very vague ideas, phrased as \"I would like to\". I've gone with \"would like to\" rather than \"will\" as life is hard, things change, and your definition of success might (and likely will) have to change to reflect those new circumstances. That said my goals are:\n\n1. I would like to improve my health\n2. I would like to paint and play a 1k point game with one of my 40k armies\n3. I would like to ship at least one of my unfinished projects\n",
      "tags": [
        "Life",
        "YearInReview"
      ],
      "hero": null,
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2023/2022_year_in_review/2022-obsidian-graph.png",
          "alt": "Screenshot of obsidan graph",
          "date": "2023-01-08T16:10:00.000Z",
          "parentPermalink": "/blog/2022-a-year-in-review",
          "width": 2018,
          "height": 1730,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2023/2022_year_in_review/2022-obsidian-graph-full.png",
          "alt": "Screenshot of obsidan graph",
          "date": "2023-01-08T16:10:00.000Z",
          "parentPermalink": "/blog/2022-a-year-in-review",
          "width": 1720,
          "height": 1616,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "leaving-the-twitter-nest": {
      "key": "leaving-the-twitter-nest",
      "permalink": "/blog/leaving-the-twitter-nest",
      "title": "Leaving the Twitter nest",
      "date": "2022-11-15T19:10:00.000Z",
      "description": "A look back at why I left Twitter, some of my favourite posts and funny retweets",
      "content": "Twitter had never really captured my interest. I used to be, and still mostly am, a private person who rarely shares what they're up to with the broader world. This led to me tweeting very little and primarily using it to doomscroll and retweet anything that caused a reaction in me.\n\nWith that said, there were some good moments, either inspired tweets I've retweeted or when I really gave it a go and tried to make it work. This will be a guided tour of everything that made me laugh or reminded me of something good when going through my Twitter archive, so enjoy.\n\nGoing forward, I doubt I'll use Twitter for anything other than complaining to companies. I've moved to [geekyaubergine.com](https://geekyaubergine.com), which is powered by [Micro.blog](https://micro.blog) (a community/platform I'd highly recommend looking into).\n\n## My Tweets\n\n### Top Tweet\n\n2020-02-11\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/straight_banana.jpg)\n\nShocking Straight Brexit Banana. As soon as I saw this, I knew I had to reference [the straight banana rumours](https://www.europarl.europa.eu/unitedkingdom/en/news-and-press-releases/euromyths/bendybananas.html) surrounding Brexit.\n\n### The Rest\n\nThese first few tweets are cringe, enjoy\n\n---\n\n2012-04-16\n\n> I need to get a good photo for my avatar.\n\nThe first tweet, how boring\n\n---\n\n2012-10-13\n\n> I do love it when my program's finally start to look promising. #Python\n\n---\n\n2012-11-05\n\n> So, it would appear last night that I impulse bought PrisonArchitect. One of my best buys this year, fantastic game. Especially for an alpha\n\nOk, maybe not cringe, but it is still a very good game\n\n---\n\n2012-11-20\n\n> I need to get a 5 x 5 x 5 Rubik's cube.\n\nI have one now and love it; sue me.\n\n---\n\n2012-11-26\n\n> Senior Maths Challenge today, could be a laugh.\n\nGod, was I cool, maths challanges, so funny hahhahahhaa\n\n---\n\n2013-01-21\n\n> I've missed #objective-c nice to finally get back to it.\n\n The worst opinion I've ever had\n\n---\n\n2013-06-13\n\n> I swear my bank account cries every time there's a steam sale.\n\nUniversal truths. Still the most I've spent in a steam sale\n\n---\n\n2013-07-24\n\n> Just seen a duck sneeze. Not sure what is was expecting, but not that.\n\nI wish I remembered what it sounded like\n\n---\n\n2013-08-02\n\n> Listening to Les Mis and programming, I call that a win.\n\nIt's a vibe\n\n---\n\n2013-08-03\n\n> The 'calm' before the storm.\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BQs3ifjCYAAXQnG.jpeg)\n\nI miss Disney. Looking out over [Crescent Lake](https://goo.gl/maps/pMcsdo1yP1kX1qzh8) heading from EPCOT to the Yacht and Beach Club/Swan and Dolphin.\n\n---\n\n2013-08-03\n\n> Burger phone\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BQxw1X2CYAAcaSG.jpeg)\n\nIf I'm not mistaken, this is just outside the bathrooms in [Adventureland](https://en.wikipedia.org/wiki/Adventureland_(Disney))\n\n---\n\n2013-10-03\n\n> Glad to say that my UCAS application is done!\n\nI remember that, screw that form\n\n---\n\n2013-11-16\n\n> The build is starting to come together (the parts at least)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BZLj3LkIEAARN5p.jpeg)\n\n---\n\n2013-11-17\n\n> Java + MySQL is a buddle of fun...\n\nTurns out I've never been able to spell\n\n---\n\n2013-12-27\n\n> I love it when you find a bug, add code to print info, and the bug is magically fixed. Gotta love #debugging\n\n🤮\n\n---\n\n2014-02-25\n\n> Nothing quiet like revision and classical music\n\nHow did I ever pass English?\n\n---\n\n2014-11-21\n\n> A design that I've been playing around with for @UP_Racing.@richboakes\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/B2-vaWzCUAEHjZN.png)\n\nGlad to see my design skills have improved a little since then\n\n---\n\n2016-06-23\n\n> And now we wait #iVoted\n\nIt was not worth the wait\n\n---\n\n2016-09-02\n\n> Doing a hard reboot on a train because it's stuck, that's a new one on me\n\nThis was interesting\n\n---\n\n2017-02-20\n\n> Oxygen Not Included by @klei is amazing, can't wait to see the finished product.\n\nI had some good opinions, and this was one of them. I still love this game\n\n---\n\n2017-02-24\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/dorris_tree.jpg)\n\nThat time [Dorris](https://www.metoffice.gov.uk/weather/warnings-and-advice/uk-storm-centre/storm-doris) took out a tree\n\n--- \n\n2017-02-28\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/pancakes_2017.jpg)\n\nSemi-successful pancakes on the worst hob I've ever used\n\n---\n\n2017-02-25\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/drunk_uber.png)\n\nUber got very drunk and thought a 10-minute drive would take 5 hours\n\n---\n\n2017-03-16\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/monzo.jpg)\n\nI got selected for the Monzo shares scheme, so I became a _proper adult_ and bought a whole 10 shares\n\n---\n\n2017-03-19\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/batb.jpg)\n\nSaw the new Beauty and The Beast movie\n\n---\n\n2017-04-29\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/15k_walking_badge.jpg)\n\nDid some walking, got a badge\n\n---\n\n2017-06-20\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/sky_notification.jpg)\n\nSky developer using prod keys\n\n---\n\n2017-08-16\n\n<img src=\"https://cdn.geekyaubergine.com/2022/leaving_twitter/DHVliMTW0AEghgm.jpeg\" />\n\nGot up far too early to see a very big ~boat~[_ship_](https://en.wikipedia.org/wiki/HMS_Queen_Elizabeth_(R08))\n\n---\n\n2017-08-26\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/DIJ3C2TXoAAvJ45.jpeg)\n\nWent to Victorious festival as a non-festival person, was alright\n\n---\n\n2017-10-19\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/DRZqLC2X0AAHeLY.jpeg)\n\nCold and beautiful morning on the last working day of the year.\n\n---\n\n2018-04-12\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/DakqmoBWsAAZrlm.jpeg)\n\nFunny train name\n\n---\n\n2018-04-18\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/DbFEyZjXkAIyI21.jpeg)\n\nTraditional first BBQ of the year post\n\n---\n\n2019-04-22\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/D4w70H3WwAASCKH.jpeg)\n\nTraditional first BBQ of the year post (yes, it was a year between good posts)\n\n---\n\n2019-05-29\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/D7uN5BuXoAIib1p.png)\n\n[IEEE 754 Go brrr](https://en.wikipedia.org/wiki/IEEE_754)\n\n---\n\n2019-10-25\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/EH0JkevX4AETp4R.jpeg)\n\n---\n\n2020-12-25\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/EqFVN4MXcAAWmme.jpeg)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/EqF7wvKXIAgrVWT.jpeg)\n\nCovid meant I couldn't go home for Christmas, so I did my first-ever roast. Very successful, all things considered, and I only set the fire alarm off once.\n\n### That time when I tried to make a Minecraft Mod\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BWpdXiOCMAAE6g_.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BXibkJACMAAxvcW.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BXhuywtCIAAhFin.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BXgy24YCcAENvMh.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BXxlPjsCMAA2kzl.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BXx0ruUCAAAymRp.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BX7oE5_CcAA1tVx.png)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/BYvslpCCYAAb362.png)\n\nI owe a lot to this mod (maybe not my windmill design skills). I learned many programming skills on a fun project I was motivated about. It's a shame it never went further than prototypes, though it was highly ambitious.\n\n## Re-tweets\n\n### Funny [this fact is disputed] Things/Memes\n\n[Just Jersey Things](https://twitter.com/JerseyPolice/status/1005022273294733313)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/police_cows.png)\n\n[trains](https://twitter.com/GeekyAubergine/status/1565648506173460482) - Featuring the official checkmark because verified means nothing, gg Elon\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_amtrak.png)\n\n[Royale Blame Game](https://twitter.com/GeekyAubergine/status/1006185633533124609)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_royal_drag.png)\n\n[Haha, science jokes](https://twitter.com/GeekyAubergine/status/783291492546772992)\n\n![H2O molocule models littered on floor](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_wet_floor.png)\n\n[The internet is wrong, again](https://twitter.com/GeekyAubergine/status/1463465282924654598) - Chorus is the correct choice\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_ducks_in_a_row.png)\n\n[Skig](https://twitter.com/GeekyAubergine/status/1238401101063426048)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_skig.png)\n\n### Cool Things\n\n[Cool Fourier-Transform animation](https://twitter.com/GeekyAubergine/status/773135762892161024)\n\n![Frame from a gif showing fourier transforms](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_fft.png)\n\n[Honk!](https://twitter.com/GeekyAubergine/status/1179384033127682048)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_take_bell.png)\n\n[Singing Blobs](https://twitter.com/GeekyAubergine/status/1339166788962095106)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_singing_blobs.png)\n\n[Cool Golden Ratio animation](https://twitter.com/GeekyAubergine/status/1243589908587073536)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_golden_squares.png)\n\n### Programming Memes\n\n[Obligitory Github being down](https://twitter.com/GeekyAubergine/status/819941063850913792)\n\n![Old painting with \"Shits on fire, Yo\" written on top](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_github_fire.png)\n\n[That time with AWS S3 went down and couldn't update their status page](https://twitter.com/GeekyAubergine/status/819941063850913792)\n\n![This is fine meme template with AWS S3 status saying \"Service operating normally\"](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_aws_on_fire.png)\n\n[Sick dunk on PHP](https://twitter.com/GeekyAubergine/status/786848936447340544)\n\n![Worst pirate I've ever heard of meme with PHP over Jack Sparrow's Face](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_php_dunk.png)\n\n[Execs who don't know how to (or worse, think they do) program are fun](https://twitter.com/GeekyAubergine/status/847443710778368000)\n\n![Mr Burns meme when he's at the hospital being told he's got all the diseases](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_mr_burn_code_smells.png)\n\n[Git your Dad jokes here](https://twitter.com/GonzoHacker/status/870026285942222849)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_git_dad.png)\n\n[Speedy Secure Potatos](https://twitter.com/GeekyAubergine/status/931569799280365568)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_http_hot_potato.png)\n\n[Bacon As A Service](https://twitter.com/GeekyAubergine/status/893093929096183808)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_bacon_aas.png)\n\n[Cat Jams your Memory](https://twitter.com/GeekyAubergine/status/1329372365109735426)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_memory_leak.png)\n\n[Bucket Lady](https://twitter.com/GeekyAubergine/status/1244570257244725248)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_bucket.png)\n\n### Brexit Memes\n\n[Brexit starting gun](https://twitter.com/GeekyAubergine/status/847058040834736128)\n\n![Picture of Tom from Tom and Jerry with a misfiring gun that sprayed gunpowder over his own face](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_theresa_may_brexit_gun.png)\n\n[Honk At Bojo](https://twitter.com/GeekyAubergine/status/1176475636946411526)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_bojo_honk.png)\n\n[Poor Henry](https://twitter.com/GeekyAubergine/status/1223354669680021504)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_brexit_tunnel.png)\n\n[Boris Goes Together](https://twitter.com/GeekyAubergine/status/1223243683639721990)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_borris_greese.png)\n\n### Covid Memes\n\n[Lockdown with Malcolm Tucker](https://twitter.com/GeekyAubergine/status/1242192735660015616)\n\n![](https://cdn.geekyaubergine.com/2022/leaving_twitter/lockdown_thick_of_it.png)\n\n",
      "tags": [
        "Life",
        "SocialMedia"
      ],
      "hero": null,
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_wet_floor.png",
          "alt": "H2O molocule models littered on floor",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 1172,
          "height": 1066,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_fft.png",
          "alt": "Frame from a gif showing fourier transforms",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 1166,
          "height": 1364,
          "orientation": "portrait",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_github_fire.png",
          "alt": "Old painting with \"Shits on fire, Yo\" written on top",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 590,
          "height": 619,
          "orientation": "portrait",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_aws_on_fire.png",
          "alt": "This is fine meme template with AWS S3 status saying \"Service operating normally\"",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 593,
          "height": 376,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_php_dunk.png",
          "alt": "Worst pirate I've ever heard of meme with PHP over Jack Sparrow's Face",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 582,
          "height": 525,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_mr_burn_code_smells.png",
          "alt": "Mr Burns meme when he's at the hospital being told he's got all the diseases",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 1158,
          "height": 1022,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/leaving_twitter/tweet_theresa_may_brexit_gun.png",
          "alt": "Picture of Tom from Tom and Jerry with a misfiring gun that sprayed gunpowder over his own face",
          "date": "2022-11-15T19:10:00.000Z",
          "parentPermalink": "/blog/leaving-the-twitter-nest",
          "width": 1152,
          "height": 1006,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "creating-a-microblog-theme": {
      "key": "creating-a-microblog-theme",
      "permalink": "/blog/creating-a-microblog-theme",
      "title": "Creating a Micro.blog Theme + Tailwind",
      "date": "2022-05-27T20:19:00.000Z",
      "description": "How I built my custom Micro.blog theme with Tailwind",
      "content": "After having messed around with [Micro.blog](https://micro.blog) for a while, I decided I wanted to have a go at building my own them. At first, the challenge seemed relatively easy as there were many other themes already out there, but I was soon to be proven wrong. Hopefully, I can steer you in the right direction to save you some time.\n\nI further complicated things by wishing to style everything using [Tailwind](https://tailwindcss.com/), this is optional, of course, but it did complicate things further.\n\nMany thanks to [Robb Knight](https://rknight.me), who's worked with me to understand some of this weirdness.\n\nYou might also find reading [Colin Devroe](https://cdevroe.com/2021/03/29/notes-mb-themes/)'s post about creating a Micro.blog theme useful.\n\n## 1. Prepping your environment\n\nMicro.blog is powered by [Hugo](https://gohugo.io/), you will need to install that.\n\nOnce you've installed Hugo, create a new site and open that directory.\n\n## 2. Getting the right version of Hugo\n\nThe first challenge was getting something running. There are some differences between [Hugo](https://gohugo.io/) and [Micro.blog](https://micro.blog), and overcoming them proved annoying. The first thing to ensure is you have Hugo version 0.91.0 installed, anything newer, and you'll get issues with almost all templates relying on some RSS data that no longer exists.\n\nOnce you have the executable from the website, drag it into your site's main folder, this will allow you to run `./hugo` for all other commands, and you'll have the correct version.\n\n## 3. Getting your data\n\nGo to your Micro.blog, go to 'design', and click on the 3 dots next to your domain name.\n\n![Micro.blog UI showing where to find the Export button](https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-26-18-18-37.png)\n\nOnce you get here, click \"Export\" and download your \"Theme and Markdown\" as a \".zip\".\n\nOnce this has been downloaded, copy the `content` and `data` folder into your Hugo site.\n\nIf you have posts with photos, you will have to replace the URLs as they don't work correctly and won't have been downloaded. You can go through each post and add your domain to the front of each URL. For example, mine went from \n\n```bash\nuploads/2022/11510a1600.png\n```\n\nto\n\n\n```bash\nhttps://geekyaubergine.com/uploads/2022/11510a1600.png\n```\n\nIf you want to cheat as I did, perform global replace on the content folder focus-within:\n\n```bash\nfind: 'src=\"u'\nreplace: 'src=\"https://geekyaubergine.com/u'\n```\n\n## 4. Getting configured\n\nFrom the data you downloaded before, you will need to take your `config.json` file and [convert it to TOML](https://www.convertsimple.com/convert-json-to-toml/). Once you've done this, copy it into your `config.toml` file.\n\n## 5. Prepping your theme\n\nI would recommend downloading the [blank](https://github.com/microdotblog/theme-blank) theme. This will give you all the required files, but you won't see anything. To fix that also download the [default](https://github.com/microdotblog/theme-default).\n\nThankfully Hugo is nice and allows you to merge themes, so import the blank theme into a 'blank' folder and the default into a 'default' folder. You can then add the following to your `config.toml` file (near the top as you'll want this again in a minute).\n\n```toml\ntheme=['default', 'blank']\n```\n\n## 6. Validate your environment\n\nAt this point, you should be able to run and see your content with the default theme.\n\n```bash\n./hugo server\n```\n\nCongrats, now we can customise it.\n\n## 7. Build your theme\n\nCreate a new theme using the following command.\n\n```bash\nhugo new theme <theme_name>\n``` \n\nInside your `config.toml` you can now add:\n\n```toml\ntheme=['theme_name', 'blank']\n``` \n\nYou can now do what you want. I recommend copying files from either `default` or `blank` into your theme and then updating them as you see fit. \n\nAn example of what your theme might look like can be found on [my repo](https://github.com/GeekyAubergine/zoeaubert-micro-theme).\n\n## 8. Deploying your theme\n\nNow you have your theme and you're happy with it, let's deploy it. Firstly you need to push your changes to a *public* git repo. Then go to your Micro.blog and go to `Design`. Here you will find the `Edit Custom Themes` button, click this and click `Create New Theme`. It should look something like this:\n\n![Micro.blog UI showing the create theme screen](https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-27-19-40-24.png)\n\nInsert whatever name for the theme you like. One quirk of Micro.blog is that if you push changes to your theme's repo, it will not automatically update on Micro.blog. To remedy this, I _strongly_ recommend you put some sort of version or timestamp at the end of your theme name to allow you to create new ones after each update. Then insert the _https_ link to your repo, the ssh link will not work. It should look something like this:\n\n![Micro.blog UI showing a filled in create theme screen](https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-27-19-43-32.png)\n\nClick `Add Theme`, check your new theme is listed there correctly and go back to `Design`. In the `Custom theme` drop-down, you should now see your newly created theme, select it and then click `Update Blog Settings` , this will deploy your changes, though it may take a minute to process.\n\nAt this point, you might see an error appear on the `Design` page. If you do see if the error makes sense, it might be something requiring a file you've not committed (that's what happened to me), or you've got something in a `{{ if hugo.IsProduction }}` block that's causing an error you didn't see on your test site. Fix them and create a new theme as described above. If successful, the error might stay around for a while but eventually disappear. \n\n\n## Tailwind\n\nHugo doesn't support Tailwind out of the box, so we need to do our own thing. \n\nI have an `assets/css/styles.css` file where I put all my styles.\n\nYou will need to have [node](https://nodejs.org/en/) installed and running. You're also going to want to install the same packages as [I have](https://github.com/GeekyAubergine/zoeaubert-micro-theme). After that, copy and modify the `postcss.config.js` and `tailwind.config.js`.\n\nYou're going to have to have Tailwind watching to rebuild your css for Hugo as it can't do it, so run: \n\n```bash\nnpx tailwindcss -i .https://cdn.geekyaubergine.com/css/styles.css -o .https://cdn.geekyaubergine.com/css/tw.css --watch --minify\n```\n\nIn your templates/layouts/partials you're going to need something like this:\n```html\n{{ $css := resources.Get \"css/tw.css\" | minify }}\n<link rel=\"preload stylesheet\" as=\"style\" href=\"{{ $css.Permalink }}\" />\n\n{{ if not hugo.IsProduction }}\n{{ $styles := resources.Get \"css/styles.css\" }}\n{{ $styles = $styles | resources.ExecuteAsTemplate (printf \"css/styles.dev.%v.css\" now.UnixMilli) . }}\n<link href=\"{{ $styles.RelPermalink }}\" rel=\"stylesheet\" />\n{{ end }}\n```\n\nThis tells Hugo to watch the file generated by Tailwind and ignores your non-compiled files in production mode. Congrats, that should be it. \n\nDon't forget to have the `tw.css` file committed to your repo, otherwise, it won't work with Micro.blog. Yes, I also dislike having a generated file committed.\n\nAn example of what configuration might look like can be found on [my repo](https://github.com/GeekyAubergine/zoeaubert-micro-theme).",
      "tags": [
        "Programming",
        "Hugo",
        "Design"
      ],
      "hero": null,
      "images": [
        {
          "src": "https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-26-18-18-37.png",
          "alt": "Micro.blog UI showing where to find the Export button",
          "date": "2022-05-27T20:19:00.000Z",
          "parentPermalink": "/blog/creating-a-microblog-theme",
          "width": 229,
          "height": 148,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-27-19-40-24.png",
          "alt": "Micro.blog UI showing the create theme screen",
          "date": "2022-05-27T20:19:00.000Z",
          "parentPermalink": "/blog/creating-a-microblog-theme",
          "width": 677,
          "height": 169,
          "orientation": "landscape",
          "title": null
        },
        {
          "src": "https://cdn.geekyaubergine.com/2022/creating_a_microblog_theme/2022-05-27-19-43-32.png",
          "alt": "Micro.blog UI showing a filled in create theme screen",
          "date": "2022-05-27T20:19:00.000Z",
          "parentPermalink": "/blog/creating-a-microblog-theme",
          "width": 678,
          "height": 227,
          "orientation": "landscape",
          "title": null
        }
      ]
    },
    "transferring-a-spotify-playlist": {
      "key": "transferring-a-spotify-playlist",
      "permalink": "/blog/transferring-a-spotify-playlist",
      "title": "Transferring a Spotify Playlist",
      "date": "2019-11-02T00:00:00.000Z",
      "description": "How to easily transfer a Spotify playlist between two accounts",
      "content": "Transferring playlists on Spotify can be a rather tedious process, there are many different approaches talked about online but I think I may have found the easiest way yet.\n\n1. Log into your _new_ account using the Spotify app on your PC\n2. Log into your _old_ account using the Spotify web client\n3. On your new account create a new playlist for each playlist you want to transfer\n4. On the web, click on a playlist you want to transfer and copy-paste the URL into the search bar of your app\n5. Once the playlist has loaded click on a song, select all the other songs in the playlist and then drag and drop the songs onto the new playlist\n6. Repeat until all your playlists are transferred\n\nHopefully, this will make the process much less frustrating for you the next time you need to do this.\n",
      "tags": [
        "Tech"
      ],
      "hero": null,
      "images": []
    },
    "optimising-nested-database-operations": {
      "key": "optimising-nested-database-operations",
      "permalink": "/blog/optimising-nested-database-operations",
      "title": "Optimising Nested Database Operations",
      "date": "2019-02-23T00:00:00.000Z",
      "description": "A discussion in reducing nested database calls",
      "content": "Nested loops - love them or hate them - are often a necessary evil within many\nprogramming problems; whether it’s to traverse n-dimensional matrices or\niterating over the children of objects, they provide the cleanest solutions.\nWe’ll discuss the latter example and how it is sometimes possible to unravel\nsome of the loops to reduce the complexity of the problem many times over.\n\nImagine you've been given a task; given an array of many objects of class Alpha,\nlist all children Delta, along with related data from Bravo and Charlie which\nalso are children of Alpha. While this sounds like a relatively simple task at\nfirst glance, you then remember that Delta does not directly belong to Alpha,\nbut instead to Charlie, which in turn belong to Bravo, and Bravo’s belong to\nAlpha. The problem has now become much harder requiring traversal through three\nlayers of children to access Delta.\n\nAn important thing to consider is whether or not the Alpha objects already have\nthese children loaded into memory, or they need to retrieve from the database,\nthis will greatly affect the required approach. Both the [database](#using-databases)\nand [preloaded](#using-preloaded-data) approaches can be found below.\n\nWe’ll use javascript in these examples but the techniques discussed will be\napplicable to any language - I first implemented this solution in PHP.\nAdditionally, we’ll assume that `alphas` is an array of Alpha that has been\ngiven as an argument to this function, and we’ll assume all operations are\nsynchronous.\n\nOne final thing to consider before we access solutions; it may be entirely\nunnecessary for you to implement any of these solutions if there is not already,\nor soon going to be, a significant performance problem within your program as\nyou’ll likely introduce further complexities while also reducing readability\nwhich is something we should all strive to avoid.\n\n> Premature optimization is the root of all evil\n>\n> <cite>Donald Knuth</cite>\n\n## Using databases\n\nAs we will be loading data from the database, it is worth considering the\nexpensive nature database queries in terms of execution time and reducing the\nload on the database.\n\nLet’s start with a simplistic solution that, while not ideal, is readable and\ncompletes the task.\n\n```js\nconst output = [];\n\nfor (const alpha in alphas) {\n  const bravos = database.findAllBravosByAlphaId(alpha.id);\n  for (const bravo in bravos) {\n    const charlies = database.findAllCharliesByBravoId(bravo.id);\n    for (const charlie in charlies) {\n      const deltas = database.findAllDeltasByCharlieId(charlie.id);\n      for (const delta in deltas) {\n        output.push({\n          w: alpha.w,\n          x: bravo.x,\n          y: charlie.y,\n          z: delta.z,\n        });\n      }\n    }\n  }\n}\n\nreturn output;\n```\n\nThere are many issues with this solution, not only is the quadruple nested loop\nis rather unforgiving when it comes to complexity growth - `O(n^4)`, but this\nalso results in a significant number of database queries. For example, if we\nassume that for every Alpha there are 10 Bravos, for every Bravo 20 Charlies,\nand for every Charlie, there are 5 Deltas; then the number of database queries\nare `1000n`, where n is the number of Alphas. This is clearly rather\nproblematic, thankfully though we can slowly begin to unravel the inner loops,\nlets first do this by pulling out the database queries which are the most\nexpensive part.\n\n```js\nconst output = [];\n\nfor (const alpha in alphas) {\n  const bravos = database.findAllBravosByAlphaId(alpha.id);\n  const bravoIds = bravos.map((b) => b.id);\n\n  const charlies = database.findAllCharliesByBravoIds(bravoIds);\n  const charlieIds = charlies.map((c) => c.id);\n\n  const deltas = database.findAllDeltasByCharlieIds(charlieIds);\n\n  for (const bravo in bravos) {\n    for (const charlie in charlies) {\n      for (const delta in deltas) {\n        output.push({\n          w: alpha.w,\n          x: bravo.x,\n          y: charlie.y,\n          z: delta.z,\n        });\n      }\n    }\n  }\n}\n\nreturn output;\n```\n\nWhile this solution leaves a lot to be desired it is a vast improvement over the\nprevious one. The crux of the solution lies on lines 5, 7, 8 and 10. On line 5\nwe retrieve produce a simple array that contains all the Bravos we will need,\nwhich we can then use on 7 to find all Charlies which belong to any of these\nBravos. A similar approach is repeated on lines 8 and 10 to retrieve all Deltas.\nWe’ve now reduced our required number of database queries to `3n`; this is a\nsignificant improvement already and should improve the performance of this\nprogram many times over, but there is still the annoying presence of the\nquadruple nested loop, these too can be extracted.\n\n```js\nconst output = []\n\nfor (const alpha in alphas) {\n  const bravos = database.findAllBravosByAlphaId(alpha.id)\n  const bravoIds = bravos.map(b => b.id)\n  const bravoIdMap = bravos.reduce((acc, b) => { ...acc, [b.id]: b }, {})\n\n  const charlies = database.findAllCharliesByBravoIds(bravoIds)\n  const charlieIds = charlies.map(c => c.id)\n  const charlieIdMap = charlies.reduce((acc, c) => { ...acc, [c.id]: c }, {})\n\n  const deltas = database.findAllDeltasByCharlieIds(charlieIds)\n\n  for (const delta in deltas) {\n    const charlie = charlies.find(c => c.id === delta.charlieId)\n    const bravo = bravos.find(b => b.id === charlie.bravoId)\n    output.push({\n      w: alpha.w,\n      x: bravo.x,\n      y: charlie.y,\n      z: delta.z,\n    })\n  }\n}\n\nreturn output\n```\n\nThis solution looks to be a large improvement as we have now removed two of the\nnested loops; although upon closer inspection we can see this isn’t true as it\nrelies upon an array `.find` on lines 15 and 16, which sadly re-introduces a\nloop. We’ve now reduced the complexity from `O(n^4)` to `O(n^3)` which is a good\nstart, though it can be improved yet further by doing more pre-computation.\n\n```js\nconst output = []\n\nfor (const alpha in alphas) {\n  const bravos = database.findAllBravosByAlphaId(alpha.id)\n  const bravoIds = bravos.map(b => b.id)\n  const bravoIdMap = bravos.reduce((acc, b) => { ...acc, [b.id]: b }, {})\n\n  const charlies = database.findAllCharliesByBravoIds(bravoIds)\n  const charlieIds = charlies.map(c => c.id)\n  const charlieIdMap = charlies.reduce((acc, c) => { ...acc, [c.id]: c }, {})\n\n  const deltas = database.findAllDeltasByCharlieIds(charlieIds)\n\n  for (const delta in deltas) {\n    const charlie = charlieIdMap[delta.charlieId]\n    const bravo = bravoIdMap[charlie.bravoId]\n    output.push({\n      w: alpha.w,\n      x: bravo.x,\n      y: charlie.y,\n      z: delta.z,\n    })\n  }\n}\n\nreturn output\n```\n\nThe pre-computation here is on lines 6 and 10. By precomputing an object with\nkey-value pair mappings - similar to a hashmap - and using them in the inner\nloop the complexity has been reduced yet again to `O(n^2)` as a object/hashmap\nget operation is traditionally an `O(n)` operation. There is one final step we\ncould take to improve performance, though it is at the cost of both memory\nusage - though should still be lower than that of the [preloaded](#using-preloaded-data)\napproach - and a significant reduction in the readability of the solution.\n\n```js\n\nconst output = []\n\nconst alphaIds = alphas.map(a => a.id)\nconst alphaIdMap = alphas.reduce((acc, a) => { ...acc, [a.id]: a}, {})\n\nconst bravos = database.findAllBravosByAlphaIds(alphas)\nconst bravoIds = bravos.map(b => b.id)\nconst bravoIdMap = bravos.reduce((acc, b) => { ...acc, [b.id]: b }, {})\n\nconst charlies = database.findAllCharliesByBravoIds(bravoIds)\nconst charlieIds = charlies.map(c => c.id)\nconst charlieIdMap = charlies.reduce((acc, c) => { ...acc, [c.id]: c }, {})\n\nconst deltas = database.findAllDeltasByCharlieIds(charlieIds)\n\nfor (const delta in deltas) {\n  const charlie = charlieIdMap[delta.charlieId]\n  const bravo = bravoIdMap[charlie.bravoId]\n  const alpha = alphaIdMap[bravo.alphaId]\n  output.push({\n    w: alpha.w,\n    x: bravo.x,\n    y: charlie.y,\n    z: delta.z,\n  })\n}\n\nreturn output\n```\n\nSimilar to before, this solution produces another pre-computed map, though this\ntime of Alphas which allows for the removal of the outer loop. In doing so we\nhave reduced the complexity of this problem to `O(n)`. This demonstrates that\nunder the right situation it is entirely possible to remove many - if not all -\nnested loops from a program while also reducing the number of database queries\nrequired. It is worth noting though that when implementing these techniques,\npre-existing infrastructure may result in the inability to remove all loops,\nsuch as in a case where it is not possible to retrieve all Bravos for all Alphas\nas the current queries rely upon being given a single Alpha, and implementing\nsuch an approach may lead to many other headaches and potential inefficiencies.\n\n## Using preloaded data\n\nSimilarly to before, a naive approach to this problem might look something like\nthis:\n\n```js\nconst output = [];\n\nfor (const alpha in alphas) {\n  for (const bravo in alpha.bravos) {\n    for (const charlie in bravo.charlies) {\n      for (const delta in charlie.deltas) {\n        output.push({\n          w: alpha.w,\n          x: bravo.x,\n          y: charlie.y,\n          z: delta.z,\n        });\n      }\n    }\n  }\n}\n\nreturn output;\n```\n\nFollowing a similar technique to which we used for the database approach, we can\nextract the outer loops to use maps again.\n\n```js\nconst output = []\n\nconst alphaIdMap = alphas.reduce((acc, a) => { ...acc, [a.id]: a}, {})\n\nconst bravos = alphas.reduce((acc, a) => acc.concat(a), [])\nconst bravoIdMap = bravos.reduce((acc, b) => { ...acc, [b.id]: b }, {})\n\nconst charlies = bravos.reduce((acc, b) => acc.concat(b), [])\nconst charlieIdMap = charlies.reduce((acc, c) => { ...acc, [c.id]: c }, {})\n\nconst deltas = charlies.reduce((acc, c) => acc.concat(c), [])\n\nfor (const delta in deltas) {\n  const charlie = charlieIdMap[delta.charlieId]\n  const bravo = bravoIdMap[charlie.bravoId]\n  const alpha = alphaIdMap[bravo.alphaId]\n  output.push({\n    w: alpha.w,\n    x: bravo.x,\n    y: charlie.y,\n    z: delta.z,\n  })\n}\n```\n\nWhile this solution again achieves `O(n)` complexity, it is very important to\nnote that this approach will significantly increase the memory footprint of the\nprogram, as we are effectively doubling the memory required to store all\nentities other than Deltas. Similarly to before if this memory increase turns\nout to be a limiting factor it is reasonable to re-introduce loops to meet the\nrequirements, though if you’re doing this re-implement from the outside in as\nthis will have a much greater impact.\n",
      "tags": [
        "Programming"
      ],
      "hero": null,
      "images": []
    },
    "an-adventure-into-diffing-algorithms": {
      "key": "an-adventure-into-diffing-algorithms",
      "permalink": "/blog/an-adventure-into-diffing-algorithms",
      "title": "An Adventure Into Diffing Algorithms",
      "date": "2016-11-01T00:00:00.000Z",
      "description": "A dive into the wild world of building a custom diffing algorithms",
      "content": "A while ago at work, we decided that our current diffing algorithm was not\nmeeting our requirements. At the time we were using\n[FineDiff](http://www.raymondhill.net/finediff/viewdiff-ex.php), while this\nlibrary is good at dealing with common situations, it was unable to handle some\nof our more complicated inputs. The main complications we faced were our use of\n`;` to separate items and the addition and removal of line breaks without the\nmeaning of the content changing.\n\nInput A:  \nAlpha\n\nInput B:  \nAlpha; Beta\n\nOriginal output:  \n~~Alpha~~_Alpha; Beta_\n\nDesired output:  \nAlpha; _Beta_\n\nIn this case, the element `Beta` has been added to the input string, when doing\nthis our software added the `;` separator between the elements. This results in\nthe original `Alpha` being compared to `Alpha;` which results in the diffing\nalgorithm determining that they are different words and mark them as a complete\nreplacement.\n\nInput A:  \nAlpha; Beta\n\nInput B:  \nAlpha;\nBeta\n\nOriginal output:  \nAlpha; ~~Beta~~\n_Beta_\n\nDesired output:  \nAlpha;\nBeta\n\nIn this case, the addition of the line break between `Alpha` and `Beta` causes\nit to identify it as a new word and complicates the output (it should be noted\nthat some algorithms can be configured to ignore newlines).\n\nThe results from the longest common subsequence implementation provided marginal\nimprovements, with our usage of `;` as a separator character. To further improve\nthis I arrived at a solution of each input being tokenised using whitespace as\nseparators, I then take these tokens and process a copy of them removed the `;`\nand `\\n` characters, for example:\n\nInput:  \n`Alpha; Bravo, Charlie; Delta`\n\nRaw Tokens:  \n`Alpha;` `Bravo, Charlie;` `Delta`\n\nClean Tokens:  \n`Alpha` `Bravo, Charlie` `Delta`\n\nUpon doing this to each set of inputs the algorithm could be performed against\nthe clean tokens, and the resulting diff would produce the results we wanted. It\nwas then just a case of keeping a reference to the raw token and replacing the\ncleaned token with it when reconstructing the output string. The output from the\nalgorithm performed significantly better than we had expected.\n\nIt became quickly apparent that while the new algorithm performed well, it was\nprone to producing verbose outputs (this was true of the previous implementation\nas well).\n\nInput A: a c d f g i k\n\nInput B: a b d e g h i j\n\nOutput: a _b_ ~~c~~ d _e_ ~~f~~ g _h_ i _j_ ~~k~~\n\nAs you can see this output is incredibly verbose and complicated and proved\nunusable for many users. We decided that if there were a significant amount of\ndifference between the input and outputs, then it would be displayed as a before\nand after text, in the last example this would produce:\n\n~~a c d f g i k~~\n_a b d e g h i j_\n\nThis additional was as difficult to implement reliably as the general diffing\nalgorithm as it relied upon determining if the percentage diff was above a given\nthreshold per line, and then amending the output as required. Firstly the output\nof the diffing algorithm is rendered into HTML tags and then split by `\\n`, each\nline then have `line.replace(/<\\w>.*?<\\/\\w>/sg, '')` applied to it to remove all\ntext between tags, this allowed us to determine how many characters difference\nthere was between the lines. If the calculated percentage was over the threshold\ntwo new string would be created, the first using\n`line.replace(/(<i>.*?<\\/i>)|(<(s|\\/s)>)/gs, '')` to remove all italics tags and\nany text between strikethroughs, and the second with the inverse operation\n`line.replace(/(<s>.*?<\\/s>)|(<(i|\\/i)>)/gs, ''`. This new output or the\noriginal line is then appended to the final output of the algorithm.\n",
      "tags": [
        "Programming",
        "DiffingAlgorithms",
        "Algorithms"
      ],
      "hero": null,
      "images": []
    },
    "glory-unto-four": {
      "key": "glory-unto-four",
      "permalink": "/blog/glory-unto-four",
      "title": "Glory Unto Four",
      "date": "2015-01-25T00:00:00.000Z",
      "description": "I made a meme programming language and it was terrible",
      "content": "## Disclaimer/Errata\n\nThis post was retrieved from the archives of an old website. I wrote this just after Christmas during my first year of University, as such it wasn't it's best. I've left it as true to the origial as possible, though I have cleared up some aggregious errors.\n\nUnlike the original, I have also included the (terrible) source code (see bottom). No I don't know why I chose Java. Hopefully you'll find it a least a bit amusing.\n\n---\n\nI have created something both glorious and terrible, and I have called it Four.\n\nWhat is Four? That's a good question. Four came about as a result of me showing a friend [Brainfuck](https://en.wikipedia.org/wiki/Brainfuck). This spawned an idea, what if we could make something more difficult, more convoluted, thus Four was born. At the time we happened to have also been discussing 4chan (I won't link you, don't worry), and the idea was put forward to create a language only using the letter 'b', to pay homage to /b on 4chan (if you don't already know what that is, ask a friend, I would advise against looking it up personally). It's probably occurred to you that using a single character would be essentially impossible, so the choice was made to use '/' instead of space as a separator, why, because it was kinder than using 'd' and tied in very nicely with the theme we were going for.\n\nFour is a rather interesting language, made difficult not only by it's reduced command set, but also the difficulties that occur when trying to read lots of b's and accurately count them (I know, I've been there). When designing Four I settled upon 15 commands (slightly more then Brainfuck's 8), as I felt this was the best combination of utility and 'simplicity'. It also behaves in a similar way to Brainfuck in the sense that it has a 'infinite' set of values in a single dimensional array. The instructions are as follows (the row number corresponds to the number of b's:\n\n1.  Adds one to the current index\n2.  Subtracts one to the current index\n3.  Moves the current index right one position\n4.  Moves the current index left one position\n5.  Stores the current value at the current position in memory\n6.  Sets the current value at the current position to the value stored in memory\n7.  Adds the values stored in memory to the current value at the current position\n8.  Sets the value in memory to the current index\n9.  Adds one to the current value stored in memory\n10. Subtracts one from the current value stored in memory\n11. Inverts the current value in the current index\n12. Multiples the current value in the current position by 2\n13. Divides the current value in the current position by 2\n14. Starts a new loop\n15. End of loop segment\n\nSyntax:  \nAll commands must be separated by a '/'. That's it. So adding one and moving right one would be 'b/bbb/'.\n\nNotes:\n\n- And values stored in a negative index are not printed\n- At the end of the program all values are printed out\n- To print the values as numbers the first command should be 'b/'. To print the values as ASCII the first command should be 'bb/'\n\nHere's 'Hello, World!' in Four\n\n```text\nbb/\n#Set -1 13\nbbbb/\nb/b/b/b/b/b/b/b/b/b/b/b/b/\n#Grab 13\nbbbbb/\n#Set 65 across array\nbbbbbbbbbbbbbb/\nbbb/\nb/b/b/b/b/b/b/b/\nbbbbbbbbbbbb/\nbbbbbbbbbbbb/\nbbbbbbbbbbbb/\nb/\nbbbbbbbbbbbbbbb/\n#Set -2 32\nbbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/\nb/b/b/b/b/b/b/b/\nbbbbbbbbbbbb/\nbbbbbbbbbbbb/\nbbbbb/\n#Move 0\nbbb/bbb/\n#Set 0 H\nb/b/b/b/b/b/b/\n#Set 1 e\nbbb/\nbbbbbbb/\nb/b/b/b/\n#Set 2 l\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/\n#Set 3 l\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/\n#Set 4 o\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/b/b/b/\n#Set 5 ,\nbbb/\nbbbbbbbbbbbbb/\nbbbbbbbbbbbbb/\nbbbbbbb/\nbb/bb/bb/bb/\n#Set 6(space)\nbbb/\nbbbbbbbbbbbbb/\n#Set 7 W\nbbb/\nbbbbbbb/\nbb/bb/bb/bb/bb/bb/bb/bb/bb/bb/\n#Set 8 o\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/b/b/b/\n#Set 9 r\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/\n#Set 10 l\nbbb/\nbbbbbbb/\nb/b/b/b/b/b/b/b/b/b/b/\n#Set 11 d\nbbb/\nbbbbbbb/\nb/b/b\n#Set 12 !\nbbb/\nbbbbbbbbbbbbb/\nb/\n```\n\nThis outputs 'Hello, World!'.\n\nFor all those interested here's the minimised version:\n\n```text\nbb/bbbb/b/b/b/b/b/b/b/b/b/b/b/b/b/bbbbb/bbbbbbbbbbbbbb/bbb/b/b/b/b/b/b/b/b/bbbbbbbbbbbb/bbbbbbbbbbbb/bbbbbbbbbbbb/b/bbbbbbbbbbbbbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/bbbb/b/b/b/b/b/b/b/b/bbbbbbbbbbbb/bbbbbbbbbbbb/bbbbb/bbb/bbb/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/b/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbbbbbbbb/bbbbbbbbbbbbb/bbbbbbb/bb/bb/bb/bb/bbb/bbbbbbbbbbbbb/bbb/bbbbbbb/bb/bb/bb/bb/bb/bb/bb/bb/bb/bb/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/b/b/b/b/b/b/b/b/bbb/bbbbbbb/b/b/b/bbb/bbbbbbbbbbbbb/b/\n```\n\nCurrently the compiler for this project is unavailable and will be until I see a demand to make it shippable product.\n\nOverall this has been a very interesting project, regardless of how impracticable it is, it certainly turns a few faces.\n\n## The Code\n\n```java\npackage com.four.lang;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport com.geekyaubergine.geekyutil.io.FileUtils;\nimport com.geekyaubergine.geekyutil.math.MathUtil;\n\npublic class B_B {\n\n    public static final int MAX_INDEX = 100;\n    public static int type = 0;\n    public static int position = 0;\n    public static int acc = 0;\n    public static String separator = \"/\";\n\n    static HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\n    public static int parse(String[] data, int index) {\n        String command = data[index];\n        if (command.equals(\"bbbbbbbbbbbbbb\")) { //14\n            int counter = acc;\n            int end = index;\n            for (int i = index + 1; i < data.length; i++) {\n                if (data[i].equals(\"bbbbbbbbbbbbbbb\")) { //15\n                    end = i;\n                }\n            }\n            for (int n = 0; n < counter; n++) {\n                for (int j = index + 1; j < end; j++) {\n                    j = parse(data, j);\n                }\n            }\n            return end;\n        }\n        else if (command.equals(\"b\")) {\n            if (!map.containsKey(position)) {\n                map.put(position, 1);\n            } else {\n                map.put(position, map.get(position) + 1);\n            }\n        }\n        else if (command.equals(\"bb\")) {\n            if (!map.containsKey(position)) {\n                map.put(position, -1);\n            } else {\n                map.put(position, map.get(position) - 1);\n            }\n        }\n        else if (command.equals(\"bbb\")) {\n            position++;\n        }\n        else if (command.equals(\"bbbb\")) {\n            position--;\n        }\n        else if (command.equals(\"bbbbb\")) { //5\n            acc = map.get(position);\n        }\n        else if (command.equals(\"bbbbbb\")) { //6\n            map.put(position, acc);\n        }\n        else if (command.equals(\"bbbbbbb\")) { //7\n            if (!map.containsKey(position)) {\n                map.put(position, acc);\n            } else {\n                map.put(position, acc + map.get(position));\n            }\n        }\n        else if (command.equals(\"bbbbbbbb\")) { //8\n            acc = position;\n        }\n        else if (command.equals(\"bbbbbbbbb\")) { //9\n            acc++;\n        }\n        else if (command.equals(\"bbbbbbbbbb\")) { //10\n            acc--;\n        }\n        else if (command.equals(\"bbbbbbbbbbb\")) { //11\n            map.put(position, -map.get(position));\n        }\n        else if (command.equals(\"bbbbbbbbbbbb\")) { //12\n            map.put(position, map.get(position) * 2);\n        }\n        else if (command.equals(\"bbbbbbbbbbbbb\")) { //13\n            map.put(position, map.get(position) / 2);\n        }\n\n        return index;\n    }\n\n    public static void parseFile(ArrayList<String> lines) {\n        if (lines == null) {\n            return;\n        }\n        map = new HashMap<Integer, Integer>();\n        map.put(position, 0);\n\n        String dataRaw = \"\";\n        for (String line : lines) {\n            if (!line.startsWith(\"#\")) {\n                if (!line.endsWith(separator)) {\n                    line += separator;\n                }\n                dataRaw += line;\n            }\n        }\n        FileUtils.deleteFile(\"min.txt\");\n        FileUtils.addToFile(\"min.txt\", dataRaw);\n        String[] data = dataRaw.split(separator);\n\n        /* Data type */\n        String dataTypeDec = data[0];\n        if (dataTypeDec.equals(\"b\")) {\n            type = 1;\n        }\n        else if (dataTypeDec.equals(\"bb\")) {\n            type = 2;\n        }\n\n        for (int i = 1; i < data.length; i++) {\n            //System.out.println(i);\n            i = parse(data, i);\n            position = (int) MathUtil.clampFloat(position, -MAX_INDEX, MAX_INDEX);\n        }\n    }\n\n\n    public static void print() {\n        FileUtils.deleteFile(\"output.txt\");\n        String out1 = \"\";\n        String out2 = \"\";\n        for (int i = 0; i < MAX_INDEX; i++) {\n            if (map.containsKey(i)) {\n                int n = map.get(i);\n                char c = (char) (n);\n                out1 += n + \" \";\n                out2 += c;\n            }\n        }\n        String out = \"\";\n        if (type == 1) {\n            out = out1;\n        }\n        else if (type == 2) {\n            out = out2;\n        }\n        FileUtils.deleteFile(\"out.txt\");\n        FileUtils.addToFile(\"out.txt\", out);\n        System.out.println(\"Out:\");\n        System.out.println(out);\n    }\n\n    public static void runFile(String file) {\n        parseFile(FileUtils.getFileStrings(file, false));\n        print();\n    }\n\n    public static void main(String[] args) {\n        //File file = new File(\"res/test.txt\");\n        runFile(\"script.txt\");\n    }\n\n}\n```\n",
      "tags": [
        "Programming",
        "Languages"
      ],
      "hero": null,
      "images": []
    }
  },
  "entityOrder": [
    "first-games-of-40k",
    "advent-of-code-is-not-healthy-for-me",
    "advent-of-code-2023-day-11",
    "advent-of-code-2023-day-09",
    "advent-of-code-2023-day-08",
    "advent-of-code-2023-day-07",
    "advent-of-code-2023-day-06",
    "advent-of-code-2023-day-05",
    "advent-of-code-2023-day-04",
    "advent-of-code-2023-day-03",
    "advent-of-code-2023-day-02",
    "advent-of-code-2023-day-01",
    "hackathon-accelos",
    "leveraging-your-type-system",
    "hack-pompey-2023",
    "saving-my-chaos-knight",
    "2022-a-year-in-review",
    "leaving-the-twitter-nest",
    "creating-a-microblog-theme",
    "transferring-a-spotify-playlist",
    "optimising-nested-database-operations",
    "an-adventure-into-diffing-algorithms",
    "glory-unto-four"
  ]
}